name: Build Docker image

on: [push]

env:
  PARABOL_DOCKERFILE: ./docker/parabol-ubi/docker-build/dockerfiles/pipeline.dockerfile
  PARABOL_BUILD_ENV_PATH: docker/parabol-ubi/docker-build/environments/pipeline

jobs:
  build-and-push:
    runs-on: ubuntu-22.04
    permissions:
      contents: 'read'
      id-token: 'write'
    services:
      postgres:
        image: postgres:12.10-alpine
        # This env variables must be the same in the file PARABOL_BUILD_ENV_PATH
        env:
          POSTGRES_PASSWORD: "temppassword"
          POSTGRES_USER: "tempuser"
          POSTGRES_DB: "tempdb"
        ports:
          - 5432:5432
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      rethinkdb:
        image: rethinkdb:2.4.0
        ports:
          - 8080:8080
          - 28015:28015
          - 29015:29015
      redis:
        image: redis:6.2.6
        ports:
          - 6379:6379
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          buildkitd-flags: '--allow-insecure-entitlement network.host'
          driver-opts: network=host

      - id: 'auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v1'
        with:
          token_format: 'access_token'
          workload_identity_provider: ${{ secrets.GCP_WI_PROVIDER_NAME }}
          service_account: ${{ secrets.GCP_SA_EMAIL }}

      - uses: 'docker/login-action@v2'
        with:
          registry: ${{ secrets.GCP_DOCKER_REGISTRY }}
          username: 'oauth2accesstoken'
          password: '${{ steps.auth.outputs.access_token }}'

      # Generate the NODE_VERSION from the package.json
      - name: Setup environment variables for Docker build args
        run: |
          NODE_VERSION=$(jq -r -j '.engines.node|ltrimstr("^")' package.json)
          echo "NODE_VERSION=${NODE_VERSION}" >> $GITHUB_ENV

      # If we are in a branch, build the image (tags SHA and branch-name) and also push it as cache for the future.
      - name: Build and push for branches
        if: ${{github.ref_type}} == "branch"
        uses: docker/build-push-action@v4
        with:
          network: host
          allow: network.host
          file: ${{ env.PARABOL_DOCKERFILE }}
          context: .
          build-args: |
            "_NODE_VERSION=${{ env.NODE_VERSION }}"
            "_BUILD_ENV_PATH=${{ env.PARABOL_BUILD_ENV_PATH }}"
            "_SECURITY_ENABLED=true"
            "_NO_DEPS=false"
          push: true
          tags: |
            "${{ secrets.GCP_AR_PARABOL_DEV }}:${{github.sha}}"
            "${{ secrets.GCP_AR_PARABOL_DEV }}:${{github.ref_name}}"
          cache-from: type=registry,ref=${{ secrets.GCP_AR_PARABOL_DEV }}:${{github.ref_name}}-cache
          cache-to: type=registry,ref=${{ secrets.GCP_AR_PARABOL_DEV }}:${{github.ref_name}}-cache,mode=max

      # If we are in a tag, which is likely only to release the application, build the image using the cache from the master branch, not pushing it as cache afterwards.
      - name: Build and push for tags
        if: ${{github.ref_type}} == "tag"
        uses: docker/build-push-action@v4
        with:
          network: host
          allow: network.host
          file: ${{ env.PARABOL_DOCKERFILE }}
          context: .
          build-args: |
            "_NODE_VERSION=${{ env.NODE_VERSION }}"
            "_BUILD_ENV_PATH=${{ env.PARABOL_BUILD_ENV_PATH }}"
            "_SECURITY_ENABLED=true"
            "_NO_DEPS=false"
          push: true
          tags: |
            "${{ secrets.GCP_AR_PARABOL_DEV }}:${{github.sha}}"
            "${{ secrets.GCP_AR_PARABOL }}:${{github.ref_name}}"
          cache-from: type=registry,ref=${{ secrets.GCP_AR_PARABOL_DEV }}:master-cache
