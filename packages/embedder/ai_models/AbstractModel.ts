import type {Kysely} from 'kysely'
import {sql} from 'kysely'

export interface ModelConfig {
  model: string
  url: string
}

export interface EmbeddingModelConfig extends ModelConfig {
  tableSuffix: string
}

export interface GenerationModelConfig extends ModelConfig {}

export abstract class AbstractModel {
  public readonly url?: string

  constructor(config: ModelConfig) {
    this.url = this.normalizeUrl(config.url)
  }

  // removes a trailing slash from the inputUrl
  private normalizeUrl(inputUrl: string | undefined) {
    if (!inputUrl) return undefined
    const regex = /[/]+$/
    return inputUrl.replace(regex, '')
  }
}

export interface EmbeddingModelParams {
  embeddingDimensions: number
  maxInputTokens: number
  tableSuffix: string
}

export abstract class AbstractEmbeddingsModel extends AbstractModel {
  readonly embeddingDimensions: number
  readonly maxInputTokens: number
  readonly tableName: string
  constructor(config: EmbeddingModelConfig) {
    super(config)
    const modelParams = this.constructModelParams(config)
    this.embeddingDimensions = modelParams.embeddingDimensions
    this.maxInputTokens = modelParams.maxInputTokens
    this.tableName = `Embeddings_${modelParams.tableSuffix}`
  }
  protected abstract constructModelParams(config: EmbeddingModelConfig): EmbeddingModelParams
  abstract getEmbedding(content: string): Promise<number[]>

  async createTable(pg: Kysely<any>) {
    const hasTable =
      (
        await sql<number[]>`SELECT 1 FROM ${sql.id('pg_catalog', 'pg_tables')} WHERE ${sql.id(
          'tablename'
        )} = ${this.tableName}`.execute(pg)
      ).rows.length > 0
    if (hasTable) return undefined
    const vectorDimensions = this.embeddingDimensions
    console.log(`ModelManager: creating ${this.tableName} with ${vectorDimensions} dimensions`)
    await sql`
      DO $$
        BEGIN
        CREATE TABLE IF NOT EXISTS ${sql.id(this.tableName)} (
          "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          "embedText" TEXT,
          "embedding" vector(${sql.raw(vectorDimensions.toString())}),
          "embeddingsMetadataId" INTEGER NOT NULL,
          FOREIGN KEY ("embeddingsMetadataId")
            REFERENCES "EmbeddingsMetadata"("id")
            ON DELETE CASCADE
        );
        CREATE INDEX IF NOT EXISTS "idx_${sql.raw(this.tableName)}_embedding_vector_cosign_ops"
          ON ${sql.id(this.tableName)}
          USING hnsw ("embedding" vector_cosine_ops);
        END
      $$;
      CREATE OR REPLACE FUNCTION insert_metadata_in_queue_${sql.raw(this.tableName)} ()
      RETURNS TRIGGER AS $$
      BEGIN
          INSERT INTO public."EmbeddingsJobQueue" ("model", "objectType", "refId")
              VALUES ('${sql.raw(this.tableName)}', NEW."objectType", NEW."refId");
          RETURN NEW;
      END;
      $$ LANGUAGE plpgsql;

      DROP TRIGGER IF EXISTS "embeddings_metadata_to_queue_${sql.raw(
        this.tableName
      )}" on "EmbeddingsMetadata";

      CREATE TRIGGER "embeddings_metadata_to_queue_${sql.raw(this.tableName)}"

      AFTER INSERT ON "EmbeddingsMetadata"
      FOR EACH ROW
      EXECUTE PROCEDURE insert_metadata_in_queue_${sql.raw(this.tableName)}();
      `.execute(pg)

    console.log(
      `ModelManager: Queueing EmbeddingsMetadata into EmbeddingsJobQue for ${this.tableName}`
    )
    await sql`
    INSERT INTO "EmbeddingsJobQueue" ("model", "objectType", "refId")
    SELECT '${sql.raw(this.tableName)}', "objectType", "refId"
    FROM "EmbeddingsMetadata"
    ON CONFLICT DO NOTHING;
    `.execute(pg)
  }
}

export interface GenerationModelParams {
  maxInputTokens: number
}

export interface GenerationOptions {
  maxNewTokens?: number
  seed?: number
  stop?: string
  temperature?: number
  topK?: number
  topP?: number
}

export abstract class AbstractGenerationModel extends AbstractModel {
  readonly maxInputTokens: number
  constructor(config: GenerationModelConfig) {
    super(config)
    const modelParams = this.constructModelParams(config)
    this.maxInputTokens = modelParams.maxInputTokens
  }

  protected abstract constructModelParams(config: GenerationModelConfig): GenerationModelParams
  abstract summarize(content: string, options: GenerationOptions): Promise<string>
}

export default AbstractModel
