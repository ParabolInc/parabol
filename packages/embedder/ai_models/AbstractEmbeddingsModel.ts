import {sql} from 'kysely'
import getKysely from 'parabol-server/postgres/getKysely'
import {DB} from 'parabol-server/postgres/pg'
import {EMBEDDER_JOB_PRIORITY} from '../embedder'
import {AbstractModel, ModelConfig} from './AbstractModel'
import {RecursiveCharacterTextSplitter} from './RecursiveCharacterTextSplitter'

export interface EmbeddingModelParams {
  embeddingDimensions: number
  maxInputTokens: number
  tableSuffix: string
}
export type EmbeddingsTable = Extract<keyof DB, `Embeddings_${string}`>
export interface EmbeddingModelConfig extends ModelConfig {
  tableSuffix: string
}

export abstract class AbstractEmbeddingsModel extends AbstractModel {
  readonly embeddingDimensions: number
  readonly maxInputTokens: number
  readonly tableName: string
  constructor(config: EmbeddingModelConfig) {
    super(config)
    const modelParams = this.constructModelParams(config)
    this.embeddingDimensions = modelParams.embeddingDimensions
    this.maxInputTokens = modelParams.maxInputTokens
    this.tableName = `Embeddings_${modelParams.tableSuffix}`
  }
  protected abstract constructModelParams(config: EmbeddingModelConfig): EmbeddingModelParams
  abstract getEmbedding(content: string): Promise<number[] | Error>

  abstract getTokens(content: string): Promise<number[] | Error>
  splitText(content: string, chunkOverlap: number) {
    // it's actually 4 / 3, but don't want to chance a failed split
    const TOKENS_PER_WORD = 5 / 3
    const wordLimit = Math.floor(this.maxInputTokens / TOKENS_PER_WORD)
    const splitter = new RecursiveCharacterTextSplitter({chunkOverlap, chunkSize: wordLimit})
    return splitter.splitText(content)
  }

  async createEmbeddingsForModel() {
    console.log(`Queueing EmbeddingsMetadata into EmbeddingsJobQueue for ${this.tableName}`)
    const pg = getKysely()
    await pg
      .insertInto('EmbeddingsJobQueue')
      .columns(['jobData', 'priority'])
      .expression(({selectFrom}) =>
        selectFrom('EmbeddingsMetadata').select(({fn, lit}) => [
          fn('json_build_object', [
            sql.lit('model'),
            sql.lit(this.tableName),
            sql.lit('embeddingsMetadataId'),
            'id'
          ]).as('jobData'),
          lit(EMBEDDER_JOB_PRIORITY.NEW_MODEL).as('priority')
        ])
      )
      .onConflict((oc) => oc.doNothing())
  }
  async createTable() {
    const pg = getKysely()
    const hasTable =
      (
        await sql<number[]>`SELECT 1 FROM ${sql.id('pg_catalog', 'pg_tables')} WHERE ${sql.id(
          'tablename'
        )} = ${this.tableName}`.execute(pg)
      ).rows.length > 0
    if (hasTable) return undefined
    const vectorDimensions = this.embeddingDimensions
    console.log(`ModelManager: creating ${this.tableName} with ${vectorDimensions} dimensions`)
    await sql`
      DO $$
        BEGIN
        CREATE TABLE IF NOT EXISTS ${sql.id(this.tableName)} (
          "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          "embedText" TEXT,
          "embedding" vector(${sql.raw(vectorDimensions.toString())}),
          "embeddingsMetadataId" INTEGER UNIQUE NOT NULL,
          "chunkNumber" SMALLINT,
          UNIQUE("embeddingsMetadataId", "chunkNumber"),
          FOREIGN KEY ("embeddingsMetadataId")
            REFERENCES "EmbeddingsMetadata"("id")
            ON DELETE CASCADE
        );
        CREATE INDEX IF NOT EXISTS "idx_${sql.raw(this.tableName)}_embedding_vector_cosign_ops"
          ON ${sql.id(this.tableName)}
          USING hnsw ("embedding" vector_cosine_ops);
        END
      $$;
      `.execute(pg)
    await this.createEmbeddingsForModel()
  }
}
