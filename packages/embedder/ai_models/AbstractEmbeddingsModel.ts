import {sql} from 'kysely'
import getKysely from 'parabol-server/postgres/getKysely'
import {DB} from 'parabol-server/postgres/pg'
import {AbstractModel, ModelConfig} from './AbstractModel'
import {RecursiveCharacterTextSplitter} from './RecursiveCharacterTextSplitter'

export interface EmbeddingModelParams {
  embeddingDimensions: number
  maxInputTokens: number
  tableSuffix: string
}
export type EmbeddingsTable = Extract<keyof DB, `Embeddings_${string}`>
export interface EmbeddingModelConfig extends ModelConfig {
  tableSuffix: string
}

export abstract class AbstractEmbeddingsModel extends AbstractModel {
  readonly embeddingDimensions: number
  readonly maxInputTokens: number
  readonly tableName: string
  constructor(config: EmbeddingModelConfig) {
    super(config)
    const modelParams = this.constructModelParams(config)
    this.embeddingDimensions = modelParams.embeddingDimensions
    this.maxInputTokens = modelParams.maxInputTokens
    this.tableName = `Embeddings_${modelParams.tableSuffix}`
  }
  protected abstract constructModelParams(config: EmbeddingModelConfig): EmbeddingModelParams
  abstract getEmbedding(content: string): Promise<number[] | Error>

  abstract getTokens(content: string): Promise<number[] | Error>
  splitText(content: string, chunkOverlap: number) {
    // it's actually 4 / 3, but don't want to chance a failed split
    const TOKENS_PER_WORD = 5 / 3
    const wordLimit = Math.floor(this.maxInputTokens / TOKENS_PER_WORD)
    const splitter = new RecursiveCharacterTextSplitter({chunkOverlap, chunkSize: wordLimit})
    return splitter.splitText(content)
  }

  async createTable() {
    const pg = getKysely()
    const hasTable =
      (
        await sql<number[]>`SELECT 1 FROM ${sql.id('pg_catalog', 'pg_tables')} WHERE ${sql.id(
          'tablename'
        )} = ${this.tableName}`.execute(pg)
      ).rows.length > 0
    if (hasTable) return undefined
    const vectorDimensions = this.embeddingDimensions
    console.log(`ModelManager: creating ${this.tableName} with ${vectorDimensions} dimensions`)
    await sql`
      DO $$
        BEGIN
        CREATE TABLE IF NOT EXISTS ${sql.id(this.tableName)} (
          "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          "embedText" TEXT,
          "embedding" vector(${sql.raw(vectorDimensions.toString())}),
          "embeddingsMetadataId" INTEGER UNIQUE NOT NULL,
          "chunkNumber" SMALLINT,
          UNIQUE("embeddingsMetadataId", "chunkNumber"),
          FOREIGN KEY ("embeddingsMetadataId")
            REFERENCES "EmbeddingsMetadata"("id")
            ON DELETE CASCADE
        );
        CREATE INDEX IF NOT EXISTS "idx_${sql.raw(this.tableName)}_embedding_vector_cosign_ops"
          ON ${sql.id(this.tableName)}
          USING hnsw ("embedding" vector_cosine_ops);
        END
      $$;
      CREATE OR REPLACE FUNCTION insert_metadata_in_queue_${sql.raw(this.tableName)} ()
      RETURNS TRIGGER AS $$
      BEGIN
          INSERT INTO public."EmbeddingsJobQueue" ("model", "embeddingsMetadataId")
              VALUES ('${sql.raw(this.tableName)}', NEW."id");
          RETURN NEW;
      END;
      $$ LANGUAGE plpgsql;

      DROP TRIGGER IF EXISTS "embeddings_metadata_to_queue_${sql.raw(
        this.tableName
      )}" on "EmbeddingsMetadata";

      CREATE TRIGGER "embeddings_metadata_to_queue_${sql.raw(this.tableName)}"

      AFTER INSERT ON "EmbeddingsMetadata"
      FOR EACH ROW
      EXECUTE PROCEDURE insert_metadata_in_queue_${sql.raw(this.tableName)}();
      `.execute(pg)

    console.log(
      `ModelManager: Queueing EmbeddingsMetadata into EmbeddingsJobQueue for ${this.tableName}`
    )
    await sql`
    INSERT INTO "EmbeddingsJobQueue" ("model", "embeddingsMetadataId")
    SELECT '${sql.raw(this.tableName)}', "id"
    FROM "EmbeddingsMetadata"
    ON CONFLICT DO NOTHING;
    `.execute(pg)
  }
}
