"""
An integration provider that connects via OAuth1.0
"""
type IntegrationProviderOAuth1 implements IntegrationProvider {
  """
  The provider's unique identifier
  """
  id: ID!

  """
  The team that created the provider. "aGhostTeam" if global
  """
  teamId: ID!

  """
  The timestamp the provider was created
  """
  createdAt: DateTime!

  """
  The timestamp the token was updated at
  """
  updatedAt: DateTime!

  """
  The name of the integration service (GitLab, Mattermost, etc)
  """
  service: IntegrationProviderServiceEnum!

  """
  The kind of token used by this provider (OAuth2, PAT, Webhook)
  """
  authStrategy: IntegrationProviderAuthStrategyEnum!

  """
  The scope this provider configuration was created at (globally, org-wide, or by the team)
  """
  scope: IntegrationProviderScopeEnum!

  """
  true if the provider configuration should be used
  """
  isActive: Boolean!

  """
  The base URL of the OAuth1 server
  """
  serverBaseUrl: URL!
}

"""
An authentication provider configuration
"""
interface IntegrationProvider {
  """
  The provider's unique identifier
  """
  id: ID!

  """
  The team that created the provider. "aGhostTeam" if global
  """
  teamId: ID!

  """
  The timestamp the provider was created
  """
  createdAt: DateTime!

  """
  The timestamp the token was updated at
  """
  updatedAt: DateTime!

  """
  The name of the integration service (GitLab, Mattermost, etc)
  """
  service: IntegrationProviderServiceEnum!

  """
  The kind of token used by this provider (OAuth2, PAT, Webhook)
  """
  authStrategy: IntegrationProviderAuthStrategyEnum!

  """
  The scope this provider configuration was created at (globally, org-wide, or by the team)
  """
  scope: IntegrationProviderScopeEnum!

  """
  true if the provider configuration should be used
  """
  isActive: Boolean!
}

scalar DateTime

"""
The name of the service of the Integration Provider
"""
enum IntegrationProviderServiceEnum {
  jira
  github
  gitlab
  mattermost
  jiraServer
}

"""
The kind of token provided by the service
"""
enum IntegrationProviderAuthStrategyEnum {
  oauth1
  oauth2
  pat
  webhook
}

"""
The scope this provider was created on (globally, org-wide, or on the team)
"""
enum IntegrationProviderScopeEnum {
  global
  org
  team
}

scalar URL

"""
An integration provider that connects via OAuth2
"""
type IntegrationProviderOAuth2 implements IntegrationProvider {
  """
  The provider's unique identifier
  """
  id: ID!

  """
  The team that created the provider. "aGhostTeam" if global
  """
  teamId: ID!

  """
  The timestamp the provider was created
  """
  createdAt: DateTime!

  """
  The timestamp the token was updated at
  """
  updatedAt: DateTime!

  """
  The name of the integration service (GitLab, Mattermost, etc)
  """
  service: IntegrationProviderServiceEnum!

  """
  The kind of token used by this provider (OAuth2, PAT, Webhook)
  """
  authStrategy: IntegrationProviderAuthStrategyEnum!

  """
  The scope this provider configuration was created at (globally, org-wide, or by the team)
  """
  scope: IntegrationProviderScopeEnum!

  """
  true if the provider configuration should be used
  """
  isActive: Boolean!

  """
  The base URL of the OAuth2 server
  """
  serverBaseUrl: URL!

  """
  The OAuth2 client id
  """
  clientId: ID!
}

"""
An integration provider that connects via webhook
"""
type IntegrationProviderWebhook implements IntegrationProvider {
  """
  The provider's unique identifier
  """
  id: ID!

  """
  The team that created the provider. "aGhostTeam" if global
  """
  teamId: ID!

  """
  The timestamp the provider was created
  """
  createdAt: DateTime!

  """
  The timestamp the token was updated at
  """
  updatedAt: DateTime!

  """
  The name of the integration service (GitLab, Mattermost, etc)
  """
  service: IntegrationProviderServiceEnum!

  """
  The kind of token used by this provider (OAuth2, PAT, Webhook)
  """
  authStrategy: IntegrationProviderAuthStrategyEnum!

  """
  The scope this provider configuration was created at (globally, org-wide, or by the team)
  """
  scope: IntegrationProviderScopeEnum!

  """
  true if the provider configuration should be used
  """
  isActive: Boolean!

  """
  The webhook URL
  """
  webhookUrl: URL!
}

"""
An authentication strategy using Google
"""
type AuthIdentityGoogle implements AuthIdentity {
  """
  true if the email address using this strategy is verified, else false
  """
  isEmailVerified: Boolean!
  type: AuthIdentityTypeEnum!

  """
  The googleID for this strategy
  """
  id: ID!
}

"""
An authentication strategy to log in to Parabol
"""
interface AuthIdentity {
  """
  true if the email address using this strategy is verified, else false
  """
  isEmailVerified: Boolean!
  type: AuthIdentityTypeEnum!
}

"""
The types of authentication strategies
"""
enum AuthIdentityTypeEnum {
  LOCAL
  GOOGLE
}

"""
An authentication strategy using an email & password
"""
type AuthIdentityLocal implements AuthIdentity {
  """
  true if the email address using this strategy is verified, else false
  """
  isEmailVerified: Boolean!
  type: AuthIdentityTypeEnum!
}

"""
The meeting phase where all team members check in one-by-one
"""
type CheckInPhase implements NewMeetingPhase {
  """
  shortid
  """
  id: ID!
  meetingId: ID!
  teamId: ID!

  """
  The type of phase
  """
  phaseType: NewMeetingPhaseTypeEnum!
  stages: [CheckInStage!]!

  """
  The checkIn greeting (fun language)
  """
  checkInGreeting: MeetingGreeting!

  """
  The checkIn question of the week (draft-js format)
  """
  checkInQuestion: String!
}

interface NewMeetingPhase {
  """
  shortid
  """
  id: ID!
  meetingId: ID!
  teamId: ID!

  """
  The type of phase
  """
  phaseType: NewMeetingPhaseTypeEnum!
  stages: [NewMeetingStage!]!
}

"""
The phase of the meeting
"""
enum NewMeetingPhaseTypeEnum {
  lobby
  checkin
  updates
  firstcall
  agendaitems
  lastcall
  reflect
  group
  vote
  discuss
  SUMMARY
  SCOPE
  ESTIMATE
  RESPONSES
}

"""
An instance of a meeting phase item. On the client, this usually represents a single view
"""
interface NewMeetingStage {
  """
  stageId, shortid
  """
  id: ID!

  """
  The datetime the stage was completed
  """
  endAt: DateTime

  """
  foreign key. try using meeting
  """
  meetingId: ID!

  """
  The meeting this stage belongs to
  """
  meeting: NewMeeting

  """
  true if the facilitator has completed this stage, else false. Should be boolean(endAt)
  """
  isComplete: Boolean!

  """
  true if any meeting participant can navigate to this stage
  """
  isNavigable: Boolean!

  """
  true if the facilitator can navigate to this stage
  """
  isNavigableByFacilitator: Boolean!

  """
  The phase this stage belongs to
  """
  phase: NewMeetingPhase

  """
  The type of the phase
  """
  phaseType: NewMeetingPhaseTypeEnum

  """
  The datetime the stage was started
  """
  startAt: DateTime

  """
  Number of times the facilitator has visited this stage
  """
  viewCount: Int

  """
  true if a time limit is set, false if end time is set, null if neither is set
  """
  isAsync: Boolean

  """
  true if the viewer is ready to advance, else false
  """
  isViewerReady: Boolean!

  """
  the number of meeting members ready to advance, excluding the facilitator
  """
  readyCount: Int!

  """
  The datetime the phase is scheduled to be finished, null if no time limit or end time is set
  """
  scheduledEndTime: DateTime

  """
  The suggested ending datetime for a phase to be completed async, null if not enough data to make a suggestion
  """
  suggestedEndTime: DateTime

  """
  The suggested time limit for a phase to be completed together, null if not enough data to make a suggestion
  """
  suggestedTimeLimit: Float
  teamId: ID!

  """
  The number of milliseconds left before the scheduled end time. Useful for unsynced client clocks. null if scheduledEndTime is null
  """
  timeRemaining: Float
}

"""
A team meeting history for all previous meetings
"""
interface NewMeeting {
  """
  The unique meeting id. shortid.
  """
  id: ID!

  """
  The timestamp the meeting was created
  """
  createdAt: DateTime!

  """
  The id of the user that created the meeting
  """
  createdBy: ID!

  """
  The user that created the meeting
  """
  createdByUser: User!

  """
  The timestamp the meeting officially ended
  """
  endedAt: DateTime

  """
  The location of the facilitator in the meeting
  """
  facilitatorStageId: ID!

  """
  The userId (or anonymousId) of the most recent facilitator
  """
  facilitatorUserId: ID!

  """
  The facilitator team member
  """
  facilitator: TeamMember!

  """
  The team members that were active during the time of the meeting
  """
  meetingMembers: [MeetingMember!]!

  """
  The auto-incrementing meeting number for the team
  """
  meetingNumber: Int!
  meetingType: MeetingTypeEnum!

  """
  The name of the meeting
  """
  name: String!

  """
  The organization this meeting belongs to
  """
  organization: Organization!

  """
  The phases the meeting will go through, including all phase-specific state
  """
  phases: [NewMeetingPhase!]!

  """
  true if should show the org the conversion modal, else false
  """
  showConversionModal: Boolean!

  """
  The time the meeting summary was emailed to the team
  """
  summarySentAt: DateTime

  """
  foreign key for team
  """
  teamId: ID!

  """
  The team that ran the meeting
  """
  team: Team!

  """
  The last time a meeting was updated (stage completed, finished, etc)
  """
  updatedAt: DateTime

  """
  The meeting member of the viewer
  """
  viewerMeetingMember: MeetingMember

  """
  Is this locked for starter plans?
  """
  locked: Boolean!
}

"""
The user account profile
"""
type User {
  """
  The userId provided by us
  """
  id: ID!
  archivedTasks(
    first: Int!

    """
    the datetime cursor
    """
    after: DateTime

    """
    The unique team ID
    """
    teamId: ID!
  ): TaskConnection
  archivedTasksCount(
    """
    The unique team ID
    """
    teamId: ID!
  ): Int

  """
  The assumed company this organizaiton belongs to
  """
  company: Company

  """
  The timestamp the user was created
  """
  createdAt: DateTime!

  """
  The domains the user is a lead of
  """
  domains: [Company!]!

  """
  The user email
  """
  email: Email!

  """
  Any super power given to the user via a super user
  """
  featureFlags: UserFeatureFlags!

  """
  An array of objects with information about the user's identities.
        More than one will exists in case accounts are linked
  """
  identities: [AuthIdentity]

  """
  true if the user is not currently being billed for service. removed on every websocket handshake
  """
  inactive: Boolean
  invoiceDetails(
    """
    The id of the invoice
    """
    invoiceId: ID!
  ): Invoice
  invoices(
    first: Int!

    """
    the datetime cursor
    """
    after: DateTime

    """
    The id of the organization
    """
    orgId: ID!
  ): InvoiceConnection

  """
  true if the user is a billing leader on any organization, else false
  """
  isAnyBillingLeader: Boolean!

  """
  true if the user is currently online
  """
  isConnected: Boolean

  """
  true if the user is the first to sign up from their domain, else false
  """
  isPatientZero: Boolean!

  """
  the reason the user account was removed
  """
  reasonRemoved: String

  """
  true if the user was removed from parabol, else false
  """
  isRemoved: Boolean!

  """
  true if all user sessions are being recorded in LogRocket, else false
  """
  isWatched: Boolean!

  """
  the endedAt timestamp of the most recent meeting they were a member of
  """
  lastMetAt: DateTime

  """
  The number of meetings the user has attended
  """
  meetingCount: Int!

  """
  The largest number of consecutive months the user has checked into a meeting
  """
  monthlyStreakMax: Int!

  """
  The number of consecutive 30-day intervals that the user has checked into a meeting as of this moment
  """
  monthlyStreakCurrent: Int!

  """
  the most important actions for the user to perform
  """
  suggestedActions: [SuggestedAction!]!

  """
  the number of times the user clicked pay later
  """
  payLaterClickCount: Int!

  """
  The timeline of important events for the viewer
  """
  timeline(
    """
    the datetime cursor
    """
    after: DateTime

    """
    the number of timeline events to return
    """
    first: Int!
  ): TimelineEventConnection!

  """
  the comments and tasks created from the discussion
  """
  discussion(
    """
    The ID of the discussion
    """
    id: ID!
  ): Discussion

  """
  the ID of the newest feature, null if the user has dismissed it
  """
  newFeatureId: ID

  """
  The new feature released by Parabol. null if the user already hid it
  """
  newFeature: NewFeatureBroadcast

  """
  url of user’s profile picture
  """
  picture: URL!

  """
  The application-specific name, defaults to email before the tld
  """
  preferredName: String!

  """
  url of user’s raster profile picture (if user profile pic is an SVG, raster will be a PNG)
  """
  rasterPicture: URL!

  """
  The last day the user connected via websocket or navigated to a common area
  """
  lastSeenAt: DateTime!

  """
  The paths that the user is currently visiting. This is null if the user is not currently online. A URL can also be null if the socket is not in a meeting, e.g. on the timeline.
  """
  lastSeenAtURLs: [String]

  """
  The meeting member associated with this user, if a meeting is currently in progress
  """
  meetingMember(
    """
    The specific meeting ID
    """
    meetingId: ID!
  ): MeetingMember

  """
  A previous meeting that the user was in (present or absent)
  """
  meeting(
    """
    The meeting ID
    """
    meetingId: ID!
  ): NewMeeting

  """
  A previous meeting that the user was in (present or absent)
  """
  newMeeting(
    """
    The meeting ID
    """
    meetingId: ID!
  ): NewMeeting

  """
  all the notifications for a single user
  """
  notifications(first: Int!, after: DateTime, types: [NotificationEnum!]): NotificationConnection!

  """
  get a single organization
  """
  organization(
    """
    the orgId
    """
    orgId: ID!
  ): Organization

  """
  The connection between a user and an organization
  """
  organizationUser(
    """
    the orgId
    """
    orgId: ID!
  ): OrganizationUser

  """
  A single user that is connected to a single organization
  """
  organizationUsers: [OrganizationUser!]!

  """
  Get the list of all organizations a user belongs to
  """
  organizations: [Organization!]!

  """
  a string with message stating that the user is over the free tier limit, else null
  """
  overLimitCopy: String

  """
  The reflection groups that are similar to the selected reflection in the Spotlight
  """
  similarReflectionGroups(
    """
    The id of the selected reflection group in the Spotlight
    """
    reflectionGroupId: ID!

    """
    Only return reflection groups that match the search query
    """
    searchQuery: String!
  ): [RetroReflectionGroup!]!
  tasks(
    """
    the number of tasks to return
    """
    first: Int!

    """
    the datetime cursor
    """
    after: DateTime

    """
    a list of user Ids that you want tasks for. if null, will return tasks for all possible team members. An id is null if it is not assigned to anyone.
    """
    userIds: [ID]

    """
    a list of team Ids that you want tasks for. if null, will return tasks for all possible active teams
    """
    teamIds: [ID!]

    """
    true to only return archived tasks; false to return active tasks
    """
    archived: Boolean = false

    """
    filter tasks by the chosen statuses
    """
    statusFilters: [TaskStatusEnum!]

    """
    only return tasks which match the given filter query
    """
    filterQuery: String

    """
    if true, include unassigned tasks. If false, only return assigned tasks
    """
    includeUnassigned: Boolean = false
  ): TaskConnection!

  """
  A query for a team
  """
  team(
    """
    The team ID for the desired team
    """
    teamId: ID!
  ): Team

  """
  The invitation sent to the user, even if it was sent before they were a user
  """
  teamInvitation(
    """
    The meetingId to check for the invitation, if teamId not available (e.g. on a meeting route)
    """
    meetingId: ID

    """
    The teamId to check for the invitation
    """
    teamId: ID
  ): TeamInvitationPayload!

  """
  all the teams the user is on that the viewer can see.
  """
  teams: [Team!]!

  """
  The team member associated with this user
  """
  teamMember(
    """
    The team the user is on
    """
    teamId: ID!

    """
    If null, defaults to the team member for this user. Else, will grab the team member. Returns null if not on team.
    """
    userId: ID
  ): TeamMember

  """
  The highest tier of any org the user belongs to
  """
  tier: TierEnum!

  """
  all the teams the user is a part of that the viewer can see
  """
  tms: [ID!]!

  """
  The timestamp the user was last updated
  """
  updatedAt: DateTime
  userOnTeam(
    """
    The other user
    """
    userId: ID!
  ): User
}

"""
A connection to a list of items.
"""
type TaskConnection {
  """
  Page info with cursors coerced to ISO8601 dates
  """
  pageInfo: PageInfoDateCursor

  """
  A list of edges.
  """
  edges: [TaskEdge!]!
}

"""
Information about pagination in a connection.
"""
type PageInfoDateCursor {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: DateTime

  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: DateTime
}

"""
An edge in a connection.
"""
type TaskEdge {
  """
  The item at the end of the edge
  """
  node: Task!
  cursor: DateTime
}

"""
A long-term task shared across the team, assigned to a single user
"""
type Task implements Threadable {
  """
  shortid
  """
  id: ID!

  """
  The rich text body of the item
  """
  content: String!

  """
  The timestamp the item was created
  """
  createdAt: DateTime!

  """
  The userId that created the item
  """
  createdBy: ID!

  """
  The user that created the item
  """
  createdByUser: User!

  """
  the replies to this threadable item
  """
  replies: [Threadable!]!

  """
  The FK of the discussion this task was created in. Null if task was not created in a discussion
  """
  discussionId: ID

  """
  the parent, if this threadable is a reply, else null
  """
  threadParentId: ID

  """
  the order of this threadable, relative to threadParentId
  """
  threadSortOrder: Float

  """
  The timestamp the item was updated
  """
  updatedAt: DateTime!

  """
  The agenda item that the task was created in, if any
  """
  agendaItem: AgendaItem

  """
  a user-defined due date
  """
  dueDate: DateTime

  """
  A list of the most recent estimates for the task
  """
  estimates: [TaskEstimate!]!

  """
  a list of users currently editing the task (fed by a subscription, so queries return null)
  """
  editors: [TaskEditorDetails!]!

  """
  The reference to the single source of truth for this task
  """
  integration: TaskIntegration

  """
  A hash of the integrated task
  """
  integrationHash: ID

  """
  the foreign key for the meeting the task was created in
  """
  meetingId: ID

  """
  the foreign key for the meeting the task was marked as complete
  """
  doneMeetingId: ID

  """
  the plain text content of the task
  """
  plaintextContent: String!

  """
  the shared sort order for tasks on the team dash & user dash
  """
  sortOrder: Float!

  """
  The status of the task
  """
  status: TaskStatusEnum!

  """
  The tags associated with the task
  """
  tags: [String!]!

  """
  The id of the team (indexed). Needed for subscribing to archived tasks
  """
  teamId: ID!

  """
  The team this task belongs to
  """
  team: Team!

  """
  The first block of the content
  """
  title: String!

  """
  * The userId, index useful for server-side methods getting all tasks under a user. This can be null if the task is not assigned to anyone.
  """
  userId: ID

  """
  The user the task is assigned to. Null if it is not assigned to anyone.
  """
  user: User

  """
  The owner hovers over the task in their solo update of a checkin
  """
  isHighlighted(
    """
    Meeting for which the highlight is checked
    """
    meetingId: ID
  ): Boolean!
}

"""
An item that can be put in a thread
"""
interface Threadable {
  """
  shortid
  """
  id: ID!

  """
  The rich text body of the item
  """
  content: String!

  """
  The timestamp the item was created
  """
  createdAt: DateTime!

  """
  The userId that created the item
  """
  createdBy: ID

  """
  The user that created the item
  """
  createdByUser: User

  """
  the replies to this threadable item
  """
  replies: [Threadable!]!

  """
  The FK of the discussion this task was created in. Null if task was not created in a discussion
  """
  discussionId: ID

  """
  the parent, if this threadable is a reply, else null
  """
  threadParentId: ID

  """
  the order of this threadable, relative to threadParentId
  """
  threadSortOrder: Float

  """
  The timestamp the item was updated
  """
  updatedAt: DateTime!
}

"""
A request placeholder that will likely turn into 1 or more tasks
"""
type AgendaItem {
  """
  The unique agenda item id teamId::shortid
  """
  id: ID!

  """
  A list of users currently commenting
  """
  commentors: [CommentorDetails!]
    @deprecated(reason: "Moved to ThreadConnection. Can remove Jun-01-2021")

  """
  The body of the agenda item
  """
  content: String!

  """
  The timestamp the agenda item was created
  """
  createdAt: DateTime

  """
  true if the agenda item has not been processed or deleted
  """
  isActive: Boolean!

  """
  True if the agenda item has been pinned
  """
  pinned: Boolean

  """
  If pinned, this is the unique id of the original agenda item
  """
  pinnedParentId: ID

  """
  The sort order of the agenda item in the list
  """
  sortOrder: Float!

  """
  *The team for this agenda item
  """
  teamId: ID!

  """
  The teamMemberId that created this agenda item
  """
  teamMemberId: ID!

  """
  The meetingId of the agenda item
  """
  meetingId: ID

  """
  The timestamp the agenda item was updated
  """
  updatedAt: DateTime

  """
  The team member that created the agenda item
  """
  teamMember: TeamMember!
}

"""
The user that is commenting
"""
type CommentorDetails {
  """
  The userId of the person commenting
  """
  id: ID!

  """
  The preferred name of the user commenting
  """
  preferredName: String!
}

"""
A member of a team
"""
type TeamMember {
  """
  An ID for the teamMember. userId::teamId
  """
  id: ID!

  """
  All the integrations that the user could possibly use
  """
  allAvailableRepoIntegrations: [RepoIntegration!]!

  """
  The datetime the team member was created
  """
  createdAt: DateTime!

  """
  true if the user is a part of the team, false if they no longer are
  """
  isNotRemoved: Boolean

  """
  Is user a team lead?
  """
  isLead: Boolean!

  """
  true if the user prefers to not vote during a poker meeting
  """
  isSpectatingPoker: Boolean!

  """
  the type of drawer that is open in the team dash. Null if the drawer is closed
  """
  openDrawer: TeamDrawer

  """
  The user email
  """
  email: Email!

  """
  url of user’s profile picture
  """
  picture: URL!

  """
  true if this team member belongs to the user that queried it
  """
  isSelf: Boolean!

  """
  The integrations that the team member has authorized. accessible by all
  """
  integrations: TeamMemberIntegrations!

  """
  The meeting specifics for the meeting the team member is currently in
  """
  meetingMember(meetingId: ID!): MeetingMember

  """
  The name of the assignee
  """
  preferredName: String!

  """
  The integrations that the user would probably like to use
  """
  repoIntegrations: RepoIntegrationQueryPayload!

  """
  Tasks owned by the team member
  """
  tasks(
    first: Int

    """
    the datetime cursor
    """
    after: DateTime
  ): TaskConnection

  """
  The team this team member belongs to
  """
  team: Team

  """
  foreign key to Team table
  """
  teamId: ID!

  """
  The user for the team member
  """
  user: User!

  """
  foreign key to User table
  """
  userId: ID!
}

"""
The suggested repos and projects a user can integrate with
"""
interface RepoIntegration {
  id: ID!
  service: IntegrationProviderServiceEnum!
}

"""
The right drawer types available on the team dashboard
"""
enum TeamDrawer {
  agenda
  manageTeam
}

scalar Email

"""
All the available integrations available for this team member
"""
type TeamMemberIntegrations {
  """
  composite
  """
  id: ID!

  """
  All things associated with an Atlassian integration for a team member
  """
  atlassian: AtlassianIntegration

  """
  All things associated with a Jira Server integration for a team member
  """
  jiraServer: JiraServerIntegration!

  """
  All things associated with a GitHub integration for a team member
  """
  github: GitHubIntegration

  """
  All things associated with a GitLab integration for a team member
  """
  gitlab: GitLabIntegration!

  """
  All things associated with a Mattermost integration for a team member
  """
  mattermost: MattermostIntegration!

  """
  All things associated with a slack integration for a team member
  """
  slack: SlackIntegration
}

"""
The atlassian auth + integration helpers for a specific team member
"""
type AtlassianIntegration {
  """
  Composite key in atlassiani:teamId:userId format
  """
  id: ID!

  """
  true if the auth is valid, else false
  """
  isActive: Boolean!

  """
  The access token to atlassian, useful for 1 hour. null if no access token available or the viewer is not the user
  """
  accessToken: ID

  """
  *The atlassian account ID
  """
  accountId: ID!

  """
  The atlassian cloud IDs that the user has granted
  """
  cloudIds: [ID!]!

  """
  The timestamp the provider was created
  """
  createdAt: DateTime!

  """
  *The team that the token is linked to
  """
  teamId: ID!

  """
  The timestamp the token was updated at
  """
  updatedAt: DateTime!

  """
  The user that the access token is attached to
  """
  userId: ID!

  """
  A list of projects accessible by this team member. empty if viewer is not the user
  """
  projects: [JiraRemoteProject!]!

  """
  the list of suggested search queries, sorted by most recent. Guaranteed to be < 60 days old
  """
  jiraSearchQueries: [JiraSearchQuery!]!
}

interface TaskIntegration {
  id: ID!
}

"""
A project fetched from Jira in real time
"""
type JiraRemoteProject implements RepoIntegration {
  id: ID!
  service: IntegrationProviderServiceEnum!

  """
  The parabol teamId this issue was fetched for
  """
  teamId: ID!

  """
  The parabol userId this issue was fetched for
  """
  userId: ID!
  self: ID!

  """
  The cloud ID that the project lives on. Does not exist on the Jira object!
  """
  cloudId: ID!
  key: String!
  name: String!
  avatar: String!
  avatarUrls: JiraRemoteAvatarUrls!
  projectCategory: JiraRemoteProjectCategory!
  simplified: Boolean!
  style: String!
}

"""
The URLs for avatars. NOTE: If they are custom, an Authorization header is required!
"""
type JiraRemoteAvatarUrls {
  x48: ID!
  x24: ID!
  x16: ID!
  x32: ID!
}

"""
A project category fetched from a JiraRemoteProject
"""
type JiraRemoteProjectCategory {
  self: String!
  id: String!
  name: String!
  description: String!
}

type StandardMutationError {
  """
  The title of the error
  """
  title: String

  """
  The full error
  """
  message: String!
}

"""
A jira search query including all filters selected when the query was executed
"""
type JiraSearchQuery {
  """
  shortid
  """
  id: ID!

  """
  The query string, either simple or JQL depending on the isJQL flag
  """
  queryString: String!

  """
  true if the queryString is JQL, else false
  """
  isJQL: Boolean!

  """
  The list of project keys selected as a filter. null if not set
  """
  projectKeyFilters: [ID!]!

  """
  the time the search query was last used. Used for sorting
  """
  lastUsedAt: DateTime!
}

"""
Jira Server integration data for a given team member
"""
type JiraServerIntegration {
  """
  The OAuth1 Authorization for this team member
  """
  auth: TeamMemberIntegrationAuthOAuth1

  """
  The non-global providers shared with the team or organization
  """
  sharedProviders: [IntegrationProviderOAuth1!]!

  """
  A list of projects accessible by this team member. empty if viewer is not the user
  """
  projects: [JiraServerRemoteProject!]!
}

"""
An integration token that connects via OAuth1
"""
type TeamMemberIntegrationAuthOAuth1 implements TeamMemberIntegrationAuth {
  """
  The token's unique identifier
  """
  id: ID!

  """
  The team that the token is linked to
  """
  teamId: ID!

  """
  The timestamp the token was created
  """
  createdAt: DateTime!

  """
  The timestamp the token was updated at
  """
  updatedAt: DateTime!

  """
  The GQL GUID of the DB providerId foreign key
  """
  providerId: ID!

  """
  The service this token is associated with, denormalized from the provider
  """
  service: IntegrationProviderServiceEnum!

  """
  true if the token configuration should be used
  """
  isActive: Boolean!

  """
  The provider strategy this token connects to
  """
  provider: IntegrationProviderOAuth1!
}

"""
The auth credentials for a token, specific to a team member
"""
interface TeamMemberIntegrationAuth {
  """
  The token's unique identifier
  """
  id: ID!

  """
  The team that the token is linked to
  """
  teamId: ID!

  """
  The timestamp the token was created
  """
  createdAt: DateTime!

  """
  The timestamp the token was updated at
  """
  updatedAt: DateTime!

  """
  The GQL GUID of the DB providerId foreign key
  """
  providerId: ID!

  """
  The service this token is associated with, denormalized from the provider
  """
  service: IntegrationProviderServiceEnum!

  """
  true if the token configuration should be used
  """
  isActive: Boolean!

  """
  The provider to connect to
  """
  provider: IntegrationProvider!
}

"""
A project fetched from Jira in real time
"""
type JiraServerRemoteProject implements RepoIntegration {
  id: ID!
  service: IntegrationProviderServiceEnum!

  """
  The parabol teamId this issue was fetched for
  """
  teamId: ID!

  """
  The parabol userId this issue was fetched for
  """
  userId: ID!
  name: String!
  avatar: String!
  avatarUrls: JiraRemoteAvatarUrls!
  projectCategory: JiraRemoteProjectCategory!
}

"""
OAuth token for a team member
"""
type GitHubIntegration {
  """
  composite key
  """
  id: ID!

  """
  The access token to github. good forever
  """
  accessToken: ID

  """
  The timestamp the provider was created
  """
  createdAt: DateTime!

  """
  true if an access token exists, else false
  """
  isActive: Boolean!

  """
  the list of suggested search queries, sorted by most recent. Guaranteed to be < 60 days old
  """
  githubSearchQueries: [GitHubSearchQuery!]!

  """
  *The GitHub login used for queries
  """
  login: ID!

  """
  The comma-separated list of scopes requested from GitHub
  """
  scope: String!

  """
  *The team that the token is linked to
  """
  teamId: ID!

  """
  The timestamp the token was updated at
  """
  updatedAt: DateTime!

  """
  The user that the access token is attached to
  """
  userId: ID!
}

"""
A GitHub search query including all filters selected when the query was executed
"""
type GitHubSearchQuery {
  """
  shortid
  """
  id: ID!

  """
  The query string in GitHub format, including repository filters. e.g. is:issue is:open
  """
  queryString: String!

  """
  the time the search query was last used. Used for sorting
  """
  lastUsedAt: DateTime!
}

"""
Gitlab integration data for a given team member
"""
type GitLabIntegration {
  """
  The OAuth2 Authorization for this team member
  """
  auth: TeamMemberIntegrationAuthOAuth2

  """
  The cloud provider the team member may choose to integrate with. Nullable based on env vars
  """
  cloudProvider: IntegrationProviderOAuth2

  """
  The non-global providers shared with the team or organization
  """
  sharedProviders: [IntegrationProviderOAuth2!]!
}

"""
An integration token that connects via OAuth2
"""
type TeamMemberIntegrationAuthOAuth2 implements TeamMemberIntegrationAuth {
  """
  The token's unique identifier
  """
  id: ID!

  """
  The team that the token is linked to
  """
  teamId: ID!

  """
  The timestamp the token was created
  """
  createdAt: DateTime!

  """
  The timestamp the token was updated at
  """
  updatedAt: DateTime!

  """
  The GQL GUID of the DB providerId foreign key
  """
  providerId: ID!

  """
  The service this token is associated with, denormalized from the provider
  """
  service: IntegrationProviderServiceEnum!

  """
  true if the token configuration should be used
  """
  isActive: Boolean!

  """
  The provider strategy this token connects to
  """
  provider: IntegrationProviderOAuth2!

  """
  The token used to connect to the provider
  """
  accessToken: ID!

  """
  The scopes allowed on the provider
  """
  scopes: String!
}

"""
Integration Auth and shared providers available to the team member
"""
type MattermostIntegration {
  """
  The OAuth2 Authorization for this team member
  """
  auth: TeamMemberIntegrationAuthWebhook

  """
  The non-global providers shared with the team or organization
  """
  sharedProviders: [IntegrationProviderWebhook!]!
}

"""
An integration authorization that connects via Webhook auth strategy
"""
type TeamMemberIntegrationAuthWebhook implements TeamMemberIntegrationAuth {
  """
  The token's unique identifier
  """
  id: ID!

  """
  The team that the token is linked to
  """
  teamId: ID!

  """
  The timestamp the token was created
  """
  createdAt: DateTime!

  """
  The timestamp the token was updated at
  """
  updatedAt: DateTime!

  """
  The GQL GUID of the DB providerId foreign key
  """
  providerId: ID!

  """
  The service this token is associated with, denormalized from the provider
  """
  service: IntegrationProviderServiceEnum!

  """
  true if the token configuration should be used
  """
  isActive: Boolean!

  """
  The provider strategy this token connects to
  """
  provider: IntegrationProviderWebhook!
}

"""
OAuth token for a team member
"""
type SlackIntegration {
  """
  shortid
  """
  id: ID!

  """
  true if the auth is updated & ready to use for all features, else false
  """
  isActive: Boolean!

  """
  the parabol bot user id
  """
  botUserId: ID

  """
  the parabol bot access token, used as primary communication
  """
  botAccessToken: ID

  """
  The timestamp the provider was created
  """
  createdAt: DateTime!

  """
  The default channel to assign to new team notifications
  """
  defaultTeamChannelId: String!

  """
  The id of the team in slack
  """
  slackTeamId: ID

  """
  The name of the team in slack
  """
  slackTeamName: String

  """
  The userId in slack
  """
  slackUserId: ID!

  """
  The name of the user in slack
  """
  slackUserName: String!

  """
  *The team that the token is linked to
  """
  teamId: ID!

  """
  The timestamp the token was updated at
  """
  updatedAt: DateTime!

  """
  The id of the user that integrated Slack
  """
  userId: ID!

  """
  A list of events and the slack channels they get posted to
  """
  notifications: [SlackNotification!]!
}

"""
an event trigger and slack channel to receive it
"""
type SlackNotification {
  id: ID!
  event: SlackNotificationEventEnum!
  eventType: SlackNotificationEventTypeEnum!

  """
  null if no notification is to be sent
  """
  channelId: ID
  teamId: ID!
  userId: ID!
}

"""
The event that triggers a slack notification
"""
enum SlackNotificationEventEnum {
  meetingStart
  meetingEnd
  MEETING_STAGE_TIME_LIMIT_END
  MEETING_STAGE_TIME_LIMIT_START
}

"""
The type of event for a slack notification
"""
enum SlackNotificationEventTypeEnum {
  """
  notification that concerns the whole team
  """
  team

  """
  notification that concerns a single member on the team
  """
  member
}

"""
All the user details for a specific meeting
"""
interface MeetingMember {
  """
  A composite of userId::meetingId
  """
  id: ID!

  """
  true if present, false if absent, else null
  """
  isCheckedIn: Boolean
    @deprecated(
      reason: "Members are checked in when they enter the meeting now & not created beforehand"
    )
  meetingId: ID!
  meetingType: MeetingTypeEnum!
  teamId: ID!
  teamMember: TeamMember!
  user: User!
  userId: ID!

  """
  The last time a meeting was updated (stage completed, finished, etc)
  """
  updatedAt: DateTime!
}

"""
The type of meeting
"""
enum MeetingTypeEnum {
  action
  retrospective
  poker
  teamPrompt
}

"""
The details associated with the possible repo and project integrations
"""
type RepoIntegrationQueryPayload {
  error: StandardMutationError

  """
  true if the items returned are a subset of all the possible integration, else false (all possible integrations)
  """
  hasMore: Boolean!

  """
  All the integrations that are likely to be integrated
  """
  items: [RepoIntegration!]
}

"""
A team
"""
type Team {
  """
  A shortid for the team
  """
  id: ID!

  """
  The datetime the team was created
  """
  createdAt: DateTime!

  """
  The userId that created the team. Non-null at v2.22.0+
  """
  createdBy: ID

  """
  true if the team was created when the account was created, else false
  """
  isOnboardTeam: Boolean!

  """
  The type of the last meeting run
  """
  lastMeetingType: MeetingTypeEnum!

  """
  The HTML message to show if isPaid is false
  """
  lockMessageHTML: String

  """
  The hash and expiration for a token that allows anyone with it to join the team
  """
  massInvitation(
    """
    the meetingId to optionally direct them to
    """
    meetingId: ID
  ): MassInvitation!

  """
  true if the underlying org has a validUntil date greater than now. if false, subs do not work
  """
  isPaid: Boolean

  """
  The name of the team
  """
  name: String!

  """
  The organization to which the team belongs
  """
  orgId: ID!

  """
  Arbitrary tags that the team uses
  """
  tags: [String]

  """
  The datetime the team was last updated
  """
  updatedAt: DateTime
  customPhaseItems: [ReflectPrompt] @deprecated(reason: "Field no longer needs to exist for now")

  """
  The outstanding invitations to join the team
  """
  teamInvitations: [TeamInvitation!]!

  """
  true if the viewer is the team lead, else false
  """
  isLead: Boolean!

  """
  The team-specific settings for running all available types of meetings
  """
  meetingSettings(
    """
    the type of meeting for the settings
    """
    meetingType: MeetingTypeEnum!
  ): TeamMeetingSettings!

  """
  A query for the scale
  """
  scale(
    """
    The scale ID for the desired scale
    """
    scaleId: ID!
  ): TemplateScale

  """
  The list of scales this team can use
  """
  scales: [TemplateScale!]!

  """
  a list of meetings that are currently in progress
  """
  activeMeetings: [NewMeeting!]!

  """
  The new meeting in progress, if any
  """
  meeting(
    """
    The unique meetingId
    """
    meetingId: ID!
  ): NewMeeting

  """
  The level of access to features on the parabol site
  """
  tier: TierEnum!
  organization: Organization!

  """
  The agenda items for the upcoming or current meeting
  """
  agendaItems: [AgendaItem!]!

  """
  All of the tasks for this team
  """
  tasks(
    first: Int

    """
    the datetime cursor
    """
    after: DateTime
  ): TaskConnection!

  """
  All the team members actively associated with the team
  """
  teamMembers(
    """
    the field to sort the teamMembers by
    """
    sortBy: String
  ): [TeamMember!]!

  """
  true if the team has been archived
  """
  isArchived: Boolean
}

"""
An invitation and expiration
"""
type MassInvitation {
  """
  the invitation token
  """
  id: ID!

  """
  the expiration for the token
  """
  expiration: DateTime!
  meetingId: ID
}

"""
Poker dimensions mapped to their corresponding fields in jira
"""
type JiraDimensionField {
  id: ID!

  """
  The atlassian cloud that the field lives in
  """
  cloudId: ID!

  """
  The name of the associated dimension
  """
  dimensionName: String!

  """
  The project under the atlassian cloud the field lives in
  """
  projectKey: ID!

  """
  The ID referring to the field name
  """
  fieldId: ID!

  """
  The field name in jira that the estimate is pushed to
  """
  fieldName: String!

  """
  the type of field, e.g. number, string, any
  """
  fieldType: String!
}

"""
A team-specific reflection prompt. Usually 3 or 4 exist per team, eg Good/Bad/Change, 4Ls, etc.
"""
type ReflectPrompt {
  """
  shortid
  """
  id: ID!
  createdAt: DateTime!

  """
  foreign key. use the team field
  """
  teamId: ID!

  """
  The team that owns this reflectPrompt
  """
  team: Team
  updatedAt: DateTime!

  """
  the order of the items in the template
  """
  sortOrder: Float!

  """
  FK for template
  """
  templateId: ID!

  """
  The template that this prompt belongs to
  """
  template: ReflectTemplate!

  """
  The question to answer during the phase of the retrospective (eg What went well?)
  """
  question: String!

  """
  The description to the question for further context. A long version of the question.
  """
  description: String!

  """
  The color used to visually group a phase item.
  """
  groupColor: String!

  """
  The datetime that the prompt was removed. Null if it has not been removed.
  """
  removedAt: DateTime
}

"""
The team-specific templates for the reflection prompts
"""
type ReflectTemplate implements MeetingTemplate {
  """
  shortid
  """
  id: ID!
  createdAt: DateTime!

  """
  True if template can be used, else false
  """
  isActive: Boolean!

  """
  The time of the meeting the template was last used
  """
  lastUsedAt: DateTime

  """
  The name of the template
  """
  name: String!

  """
  *Foreign key. The organization that owns the team that created the template
  """
  orgId: ID!

  """
  Who can see this template
  """
  scope: SharingScopeEnum!

  """
  *Foreign key. The team this template belongs to
  """
  teamId: ID!

  """
  The team this template belongs to
  """
  team: Team!

  """
  The type of the template
  """
  type: MeetingTypeEnum!
  updatedAt: DateTime!

  """
  The prompts that are part of this template
  """
  prompts: [ReflectPrompt!]!
}

"""
The scope of a shareable item
"""
enum SharingScopeEnum {
  TEAM
  ORGANIZATION
  PUBLIC
}

"""
An invitation to become a team member
"""
type TeamInvitation {
  """
  The unique invitation Id
  """
  id: ID!

  """
  null if not accepted, else the datetime the invitation was accepted
  """
  acceptedAt: DateTime

  """
  null if not accepted, else the userId that accepted the invitation
  """
  acceptedBy: ID

  """
  The datetime the invitation was created
  """
  createdAt: DateTime!

  """
  The email of the invitee
  """
  email: Email!

  """
  The datetime the invitation expires. Changes when team is archived.
  """
  expiresAt: DateTime!

  """
  The userId of the person that sent the invitation
  """
  invitedBy: ID!

  """
  The userId of the person that sent the invitation
  """
  inviter: User!

  """
  the meetingId that the invite was generated for
  """
  meetingId: ID

  """
  The team invited to
  """
  teamId: ID!

  """
  48-byte hex encoded random string
  """
  token: ID!
}

"""
The team settings for a specific type of meeting
"""
interface TeamMeetingSettings {
  id: ID!

  """
  The type of meeting these settings apply to
  """
  meetingType: MeetingTypeEnum!

  """
  The broad phase types that will be addressed during the meeting
  """
  phaseTypes: [NewMeetingPhaseTypeEnum!]!

  """
  FK
  """
  teamId: ID!

  """
  The team these settings belong to
  """
  team: Team!
}

"""
A team-specific template scale.
"""
type TemplateScale {
  """
  shortid
  """
  id: ID!
  createdAt: DateTime!

  """
  true if the scale is currently used by the team, else false
  """
  isActive: Boolean!

  """
  True if this is a starter/default scale; false otherwise
  """
  isStarter: Boolean!

  """
  The datetime that the scale was removed. Null if it has not been removed.
  """
  removedAt: DateTime

  """
  foreign key. use the team field
  """
  teamId: ID!

  """
  The team that owns this template scale
  """
  team: Team!
  updatedAt: DateTime!

  """
  The title of the scale used in the template
  """
  name: String!

  """
  The dimensions currently using this scale
  """
  dimensions: [TemplateDimension!]!

  """
  The values used in this scale
  """
  values: [TemplateScaleValue!]!
}

"""
A team-specific template dimension: e.g., effort, importance etc.
"""
type TemplateDimension {
  """
  shortid
  """
  id: ID!
  createdAt: DateTime!

  """
  true if the dimension is currently used by the team, else false
  """
  isActive: Boolean!

  """
  The datetime that the dimension was removed. Null if it has not been removed.
  """
  removedAt: DateTime

  """
  foreign key. use the team field
  """
  teamId: ID!

  """
  The team that owns this dimension
  """
  team: Team!
  updatedAt: DateTime!

  """
  the order of the dimensions in the template
  """
  sortOrder: Float!

  """
  FK for template
  """
  templateId: ID!

  """
  The template that this dimension belongs to
  """
  template: PokerTemplate!

  """
  The name of the dimension
  """
  name: String!

  """
  The description to the dimension name for further context. A long version of the dimension name.
  """
  description: String!

  """
  The scaleId to resolve the selected scale
  """
  scaleId: ID!

  """
  scale used in this dimension
  """
  selectedScale: TemplateScale!
}

"""
A value for a scale.
"""
type TemplateScaleValue {
  id: ID!

  """
  The id of the scale this value belongs to
  """
  scaleId: ID!

  """
  The color used to visually group a scale value
  """
  color: String!

  """
  The label for this value, e.g., XS, M, L
  """
  label: String!

  """
  the order of the scale value in this scale
  """
  sortOrder: Int!
}

"""
The pay tier of the team
"""
enum TierEnum {
  starter
  team
  enterprise
}

"""
A credit card
"""
type CreditCard {
  """
  The brand of the credit card, as provided by stripe
  """
  brand: String!

  """
  The MM/YY string of the expiration date
  """
  expiry: String!

  """
  The last 4 digits of a credit card
  """
  last4: String!
}

"""
A connection to a list of items.
"""
type OrganizationUserConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [OrganizationUserEdge!]!
}

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: String

  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: String
}

"""
An edge in a connection.
"""
type OrganizationUserEdge {
  """
  The item at the end of the edge
  """
  node: OrganizationUser!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
organization-specific details about a user
"""
type OrganizationUser {
  """
  orgId::userId
  """
  id: ID!

  """
  true if the user is paused and the orgs are not being billed, else false
  """
  inactive: Boolean!

  """
  the datetime the user first joined the org
  """
  joinedAt: DateTime!

  """
  The last moment a billing leader can remove the user from the org & receive a refund. Set to the subscription periodEnd
  """
  newUserUntil: DateTime!

  """
  FK
  """
  orgId: ID!

  """
  The user attached to the organization
  """
  organization: Organization!

  """
  if not a member, the datetime the user was removed from the org
  """
  removedAt: DateTime

  """
  role of the user in the org
  """
  role: OrgUserRole

  """
  FK
  """
  userId: ID!

  """
  The user attached to the organization
  """
  user: User!

  """
  Their level of access to features on the parabol site
  """
  tier: TierEnum
}

"""
The role of the org user
"""
enum OrgUserRole {
  BILLING_LEADER
}

type OrgUserCount {
  """
  The number of orgUsers who have an inactive flag
  """
  inactiveUserCount: Int!

  """
  The number of orgUsers who do not have an inactive flag
  """
  activeUserCount: Int!
}

"""
An estimate for a Task that was voted on and scored in a poker meeting
"""
type TaskEstimate {
  """
  The ID of the estimate
  """
  id: ID!

  """
  The timestamp the estimate was created
  """
  createdAt: DateTime!

  """
  The source that a change came in through
  """
  changeSource: ChangeSourceEnum!

  """
  The name of the estimate dimension
  """
  name: String!

  """
  The human-readable label for the estimate
  """
  label: String!

  """
  *The taskId that the estimate refers to
  """
  taskId: ID!

  """
  The userId that added the estimate
  """
  userId: ID!

  """
  *The meetingId that the estimate occured in, if any
  """
  meetingId: ID

  """
  The meeting stageId the estimate occurred in, if any
  """
  stageId: ID

  """
  The discussionId where the estimated was discussed
  """
  discussionId: ID

  """
  If the task comes from jira, this is the jira field that the estimate refers to
  """
  jiraFieldId: ID
}

"""
The source that a change to a record came in through
"""
enum ChangeSourceEnum {
  meeting
  task
  external
}

type TaskEditorDetails {
  """
  The userId of the person editing the task
  """
  userId: ID!

  """
  The name of the userId editing the task
  """
  preferredName: String!
}

"""
The status of the task
"""
enum TaskStatusEnum {
  active
  stuck
  done
  future
}

"""
A monthly billing invoice for an organization
"""
type Invoice {
  """
  A shortid for the invoice
  """
  id: ID!

  """
  The tier this invoice pays for
  """
  tier: TierEnum!

  """
  The amount the card will be charged (total + startingBalance with a min value of 0)
  """
  amountDue: Float!

  """
  The datetime the invoice was first generated
  """
  createdAt: DateTime!

  """
  The discount coupon information from Stripe, if any discount applied
  """
  coupon: Coupon

  """
  The total amount for the invoice (in USD)
  """
  total: Float!

  """
  The emails the invoice was sent to
  """
  billingLeaderEmails: [Email!]!

  """
  the card used to pay the invoice
  """
  creditCard: CreditCard

  """
  The timestamp for the end of the billing cycle
  """
  endAt: DateTime!

  """
  The date the invoice was created
  """
  invoiceDate: DateTime!

  """
  An invoice line item for previous month adjustments
  """
  lines: [InvoiceLineItem!]!

  """
  The details that comprise the charges for next month
  """
  nextPeriodCharges: NextPeriodCharges!

  """
  *The organization id to charge
  """
  orgId: ID!

  """
  The persisted name of the org as it was when invoiced
  """
  orgName: String!

  """
  the datetime the invoice was successfully paid
  """
  paidAt: DateTime

  """
  The URL to pay via stripe if payment was not collected in app
  """
  payUrl: String

  """
  The picture of the organization
  """
  picture: URL

  """
  The timestamp for the beginning of the billing cycle
  """
  startAt: DateTime!

  """
  The balance on the customer account (in cents)
  """
  startingBalance: Float!

  """
  the status of the invoice. starts as pending, moves to paid or unpaid depending on if the payment succeeded
  """
  status: InvoiceStatusEnum!
}

"""
The discount coupon from Stripe, if any
"""
type Coupon {
  """
  The ID of the discount coupon from Stripe
  """
  id: String!

  """
  The amount off the invoice, if any
  """
  amountOff: Int

  """
  The name of the discount coupon from Stripe
  """
  name: String!

  """
  The percent off the invoice, if any
  """
  percentOff: Int
}

"""
A single line item charge on the invoice
"""
type InvoiceLineItem {
  """
  The unique line item id
  """
  id: ID!

  """
  The amount for the line item (in USD)
  """
  amount: Float!

  """
  A description of the charge. Only present if we have no idea what the charge is
  """
  description: String

  """
  Array of user activity line items that roll up to total activity (add/leave/pause/unpause)
  """
  details: [InvoiceLineItemDetails!]!

  """
  The total number of days that all org users have been inactive during the billing cycle
  """
  quantity: Int

  """
  The line item type for a monthly billing invoice
  """
  type: InvoiceLineItemEnum!
}

"""
The per-user-action line item details,
"""
type InvoiceLineItemDetails {
  """
  The unique detailed line item id
  """
  id: ID!

  """
  The amount for the line item (in USD)
  """
  amount: Float!

  """
  The email affected by this line item change
  """
  email: Email!

  """
  End of the event. Only present if a pause action gets matched up with an unpause action
  """
  endAt: DateTime

  """
  The parent line item id
  """
  parentId: ID!

  """
  The timestamp for the beginning of the period of no charge
  """
  startAt: DateTime
}

"""
A big picture line item
"""
enum InvoiceLineItemEnum {
  ADDED_USERS
  INACTIVITY_ADJUSTMENTS
  OTHER_ADJUSTMENTS
  REMOVED_USERS
}

"""
A single line item for the charges for next month
"""
type NextPeriodCharges {
  """
  The amount for the line item (in USD)
  """
  amount: Float!

  """
  The datetime the next period will end
  """
  nextPeriodEnd: DateTime!

  """
  The total number of days that all org users have been inactive during the billing cycle
  """
  quantity: Int!

  """
  The per-seat monthly price of the subscription (in dollars), null if invoice is not per-seat
  """
  unitPrice: Float

  """
  "year" if enterprise, else "month" for pro
  """
  interval: String
}

"""
The payment status of the invoice
"""
enum InvoiceStatusEnum {
  PENDING
  PAID
  FAILED
  UPCOMING
}

"""
A connection to a list of items.
"""
type InvoiceConnection {
  """
  Page info with cursors coerced to ISO8601 dates
  """
  pageInfo: PageInfoDateCursor

  """
  A list of edges.
  """
  edges: [InvoiceEdge!]!
}

"""
An edge in a connection.
"""
type InvoiceEdge {
  """
  The item at the end of the edge
  """
  node: Invoice!
  cursor: DateTime
}

"""
A past event that is important to the viewer
"""
interface SuggestedAction {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the action was created at
  """
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """
  * The timestamp the action was removed at
  """
  removedAt: DateTime!

  """
  The specific type of suggested action
  """
  type: SuggestedActionTypeEnum!

  """
  * The userId this action is for
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!
}

"""
The specific type of the suggested action
"""
enum SuggestedActionTypeEnum {
  inviteYourTeam
  tryTheDemo
  tryRetroMeeting
  createNewTeam
  tryActionMeeting
}

"""
A connection to a list of items.
"""
type TimelineEventConnection {
  """
  Page info with cursors coerced to ISO8601 dates
  """
  pageInfo: PageInfoDateCursor

  """
  A list of edges.
  """
  edges: [TimelineEventEdge!]!
}

"""
An edge in a connection.
"""
type TimelineEventEdge {
  """
  The item at the end of the edge
  """
  node: TimelineEvent!
  cursor: DateTime
}

"""
A past event that is important to the viewer
"""
interface TimelineEvent {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the event was created at
  """
  createdAt: DateTime!

  """
  the number of times the user has interacted with (ie clicked) this event
  """
  interactionCount: Int!

  """
  true if the timeline event is active, false if archived
  """
  isActive: Boolean!

  """
  The orgId this event is associated with. Null if not traceable to one org
  """
  orgId: ID

  """
  The organization this event is associated with
  """
  organization: Organization

  """
  the number of times the user has seen this event
  """
  seenCount: Int!

  """
  The teamId this event is associated with. Null if not traceable to one team
  """
  teamId: ID

  """
  The team that can see this event
  """
  team: Team

  """
  The specific type of event
  """
  type: TimelineEventEnum!

  """
  * The userId that can see this event
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!
}

"""
The specific type of event
"""
enum TimelineEventEnum {
  retroComplete
  actionComplete
  joinedParabol
  createdTeam
  POKER_COMPLETE
  TEAM_PROMPT_COMPLETE
}

"""
A discussion thread
"""
type Discussion {
  id: ID!
  teamId: ID!
  meetingId: ID!

  """
  time the thread was created
  """
  createdAt: DateTime!

  """
  The partial foreign key that references the object that is the topic of the discussion. E.g. AgendaItemId, TaskId, ReflectionGroupId
  """
  discussionTopicId: ID!

  """
  The partial foregin key that describes the type of object that is the topic of the discussion. E.g. AgendaItem, TaskId, ReflectionGroup, GitHubIssue
  """
  discussionTopicType: DiscussionTopicTypeEnum!

  """
  The number of comments contained in the thread
  """
  commentCount: Int!

  """
  The users writing a comment right now
  """
  commentors: [User!]!

  """
  The comments & tasks thread in the discussion
  """
  thread(
    """
    How many items to show. optional if only comments are desired
    """
    first: Int

    """
    the incrementing sort order in string format
    """
    after: String
  ): ThreadableConnection!

  """
  The stage where the discussion is
  """
  stage: NewMeetingStage
}

"""
The topic being discussed
"""
enum DiscussionTopicTypeEnum {
  agendaItem
  reflectionGroup
  task
  githubIssue
  jiraIssue
}

"""
A connection to a list of items.
"""
type ThreadableConnection {
  """
  Page info with strings (sortOrder) as cursors
  """
  pageInfo: PageInfo

  """
  A list of edges.
  """
  edges: [ThreadableEdge!]!

  """
  Any errors that prevented the query from returning the full results
  """
  error: String
}

"""
An edge in a connection.
"""
type ThreadableEdge {
  """
  The item at the end of the edge
  """
  node: Threadable!
  cursor: String
}

"""
The latest feature released by Parabol
"""
type NewFeatureBroadcast {
  id: ID!

  """
  The text of the action button in the snackbar
  """
  actionButtonCopy: String!

  """
  The description of the new feature
  """
  snackbarMessage: String!

  """
  The permalink to the blog post describing the new feature
  """
  url: String!
}

"""
A connection to a list of items.
"""
type NotificationConnection {
  """
  Page info with cursors coerced to ISO8601 dates
  """
  pageInfo: PageInfoDateCursor

  """
  A list of edges.
  """
  edges: [NotificationEdge!]!
}

"""
An edge in a connection.
"""
type NotificationEdge {
  """
  The item at the end of the edge
  """
  node: Notification!
  cursor: DateTime
}

interface Notification {
  """
  A shortid for the notification
  """
  id: ID!

  """
  UNREAD if new, READ if viewer has seen it, CLICKED if viewed clicked it
  """
  status: NotificationStatusEnum!

  """
  The datetime to activate the notification & send it to the client
  """
  createdAt: DateTime!
  type: NotificationEnum!

  """
  *The userId that should see this notification
  """
  userId: ID!
}

"""
The status of the notification interaction
"""
enum NotificationStatusEnum {
  UNREAD
  READ
  CLICKED
}

"""
The kind of notification
"""
enum NotificationEnum {
  DISCUSSION_MENTIONED
  KICKED_OUT
  PAYMENT_REJECTED
  PROMOTE_TO_BILLING_LEADER
  TEAM_INVITATION
  TEAM_ARCHIVED
  TASK_INVOLVES
  MEETING_STAGE_TIME_LIMIT_END
  RESPONSE_MENTIONED
  RESPONSE_REPLIED
  TEAMS_LIMIT_EXCEEDED
  TEAMS_LIMIT_REMINDER
}

"""
A reflection group created during the group phase of a retrospective
"""
type RetroReflectionGroup {
  """
  shortid
  """
  id: ID!

  """
  A list of users currently commenting
  """
  commentors: [CommentorDetails!]
    @deprecated(reason: "Moved to ThreadConnection. Can remove Jun-01-2021")

  """
  The timestamp the meeting was created
  """
  createdAt: DateTime!

  """
  True if the group has not been removed, else false
  """
  isActive: Boolean!

  """
  The foreign key to link a reflection group to its meeting
  """
  meetingId: ID!

  """
  The retrospective meeting this reflection was created in
  """
  meeting: RetrospectiveMeeting!
  prompt: ReflectPrompt!

  """
  The foreign key to link a reflection group to its prompt. Immutable.
  """
  promptId: ID!
  reflections: [RetroReflection!]!

  """
  Our auto-suggested title, to be compared to the actual title for analytics
  """
  smartTitle: String

  """
  The sort order of the reflection group
  """
  sortOrder: Float!

  """
  The team that is running the retro
  """
  team: Team

  """
  The title of the grouping of the retrospective reflections
  """
  title: String

  """
  true if a user wrote the title, else false
  """
  titleIsUserDefined: Boolean!

  """
  The timestamp the meeting was updated at
  """
  updatedAt: DateTime

  """
  A list of voterIds (userIds). Not available to team to preserve anonymity
  """
  voterIds: [ID!]!

  """
  The number of votes this group has received
  """
  voteCount: Int!

  """
  The number of votes the viewer has given this group
  """
  viewerVoteCount: Int
}

"""
A reflection created during the reflect phase of a retrospective
"""
type RetroReflection implements Reactable {
  """
  shortid
  """
  id: ID!

  """
  All the reactjis for the given reflection
  """
  reactjis: [Reactji!]!

  """
  The ID of the group that the autogrouper assigned the reflection. Error rate = Sum(autoId != Id) / autoId.count()
  """
  autoReflectionGroupId: ID

  """
  The timestamp the meeting was created
  """
  createdAt: DateTime

  """
  The userId that created the reflection (or unique Id if not a team member)
  """
  creatorId: ID

  """
  an array of all the socketIds that are currently editing the reflection
  """
  editorIds: [ID!]!

  """
  True if the reflection was not removed, else false
  """
  isActive: Boolean!

  """
  true if the viewer (userId) is the creator of the retro reflection, else false
  """
  isViewerCreator: Boolean!

  """
  The stringified draft-js content
  """
  content: String!

  """
  The entities (i.e. nouns) parsed from the content and their respective salience
  """
  entities: [GoogleAnalyzedEntity!]!

  """
  The foreign key to link a reflection to its meeting
  """
  meetingId: ID!

  """
  The retrospective meeting this reflection was created in
  """
  meeting: RetrospectiveMeeting!

  """
  The plaintext version of content
  """
  plaintextContent: String!

  """
  The foreign key to link a reflection to its prompt. Immutable. For sorting, use prompt on the group.
  """
  promptId: ID!
  prompt: ReflectPrompt!

  """
  The foreign key to link a reflection to its group
  """
  reflectionGroupId: ID!

  """
  The group the reflection belongs to, if any
  """
  retroReflectionGroup: RetroReflectionGroup

  """
  The sort order of the reflection in the group (increments starting from 0)
  """
  sortOrder: Float!

  """
  The team that is running the meeting that contains this reflection
  """
  team: Team!

  """
  The timestamp the meeting was updated. Used to determine how long it took to write a reflection
  """
  updatedAt: DateTime
}

"""
An item that can have reactjis
"""
interface Reactable {
  """
  shortid
  """
  id: ID!

  """
  All the reactjis for the given reflection
  """
  reactjis: [Reactji!]!
}

"""
An aggregate of reactji metadata
"""
type Reactji {
  """
  composite of entity:reactjiId
  """
  id: ID!

  """
  The number of users who have added this reactji
  """
  count: Int!

  """
  true if the viewer is included in the count, else false
  """
  isViewerReactji: Boolean!
}

type GoogleAnalyzedEntity {
  """
  The lemma (dictionary entry) of the entity name. Fancy way of saying the singular form of the name, if plural.
  """
  lemma: String!

  """
  The name of the entity. Usually 1 or 2 words. Always a noun, sometimes a proper noun.
  """
  name: String!

  """
  The salience of the entity in the provided text. The salience of all entities always sums to 1
  """
  salience: Float!
}

"""
The response to a teamInvitation query
"""
type TeamInvitationPayload {
  """
  The team invitation, if any
  """
  teamInvitation: TeamInvitation

  """
  the teamId of the team trying to join
  """
  teamId: ID

  """
  one of the active meetings trying to join
  """
  meetingId: ID
}

"""
A stage that focuses on a single team member
"""
type CheckInStage implements NewMeetingStage & NewMeetingTeamMemberStage {
  """
  stageId, shortid
  """
  id: ID!

  """
  The datetime the stage was completed
  """
  endAt: DateTime

  """
  foreign key. try using meeting
  """
  meetingId: ID!

  """
  The meeting this stage belongs to
  """
  meeting: NewMeeting

  """
  true if the facilitator has completed this stage, else false. Should be boolean(endAt)
  """
  isComplete: Boolean!

  """
  true if any meeting participant can navigate to this stage
  """
  isNavigable: Boolean!

  """
  true if the facilitator can navigate to this stage
  """
  isNavigableByFacilitator: Boolean!

  """
  The phase this stage belongs to
  """
  phase: NewMeetingPhase

  """
  The type of the phase
  """
  phaseType: NewMeetingPhaseTypeEnum

  """
  The datetime the stage was started
  """
  startAt: DateTime

  """
  Number of times the facilitator has visited this stage
  """
  viewCount: Int

  """
  true if a time limit is set, false if end time is set, null if neither is set
  """
  isAsync: Boolean

  """
  true if the viewer is ready to advance, else false
  """
  isViewerReady: Boolean!

  """
  the number of meeting members ready to advance, excluding the facilitator
  """
  readyCount: Int!

  """
  The datetime the phase is scheduled to be finished, null if no time limit or end time is set
  """
  scheduledEndTime: DateTime

  """
  The suggested ending datetime for a phase to be completed async, null if not enough data to make a suggestion
  """
  suggestedEndTime: DateTime

  """
  The suggested time limit for a phase to be completed together, null if not enough data to make a suggestion
  """
  suggestedTimeLimit: Float
  teamId: ID!

  """
  The number of milliseconds left before the scheduled end time. Useful for unsynced client clocks. null if scheduledEndTime is null
  """
  timeRemaining: Float

  """
  The meeting member that is the focus for this phase item
  """
  meetingMember: MeetingMember!

  """
  foreign key. use teamMember
  """
  teamMemberId: ID!

  """
  The team member that is the focus for this phase item
  """
  teamMember: TeamMember!
}

"""
An instance of a meeting phase item. On the client, this usually represents a single view
"""
interface NewMeetingTeamMemberStage {
  """
  The meeting member that is the focus for this phase item
  """
  meetingMember: MeetingMember!

  """
  foreign key. use teamMember
  """
  teamMemberId: ID!

  """
  The team member that is the focus for this phase item
  """
  teamMember: TeamMember!
}

type MeetingGreeting {
  """
  The foreign-language greeting
  """
  content: String!

  """
  The source language for the greeting
  """
  language: String!
}

"""
The meeting phase where all team members check in one-by-one
"""
type ReflectPhase implements NewMeetingPhase {
  """
  shortid
  """
  id: ID!
  meetingId: ID!
  teamId: ID!

  """
  The type of phase
  """
  phaseType: NewMeetingPhaseTypeEnum!
  stages: [GenericMeetingStage!]!

  """
  foreign key. use focusedPrompt
  """
  focusedPromptId: ID

  """
  the Prompt that the facilitator wants the group to focus on
  """
  focusedPrompt: ReflectPrompt

  """
  The prompts used during the reflect phase
  """
  reflectPrompts: [ReflectPrompt!]!
}

"""
A stage of a meeting that has no extra state. Only used for single-stage phases
"""
type GenericMeetingStage implements NewMeetingStage {
  """
  stageId, shortid
  """
  id: ID!

  """
  The datetime the stage was completed
  """
  endAt: DateTime

  """
  foreign key. try using meeting
  """
  meetingId: ID!

  """
  The meeting this stage belongs to
  """
  meeting: NewMeeting

  """
  true if the facilitator has completed this stage, else false. Should be boolean(endAt)
  """
  isComplete: Boolean!

  """
  true if any meeting participant can navigate to this stage
  """
  isNavigable: Boolean!

  """
  true if the facilitator can navigate to this stage
  """
  isNavigableByFacilitator: Boolean!

  """
  The phase this stage belongs to
  """
  phase: NewMeetingPhase

  """
  The type of the phase
  """
  phaseType: NewMeetingPhaseTypeEnum

  """
  The datetime the stage was started
  """
  startAt: DateTime

  """
  Number of times the facilitator has visited this stage
  """
  viewCount: Int

  """
  true if a time limit is set, false if end time is set, null if neither is set
  """
  isAsync: Boolean

  """
  true if the viewer is ready to advance, else false
  """
  isViewerReady: Boolean!

  """
  the number of meeting members ready to advance, excluding the facilitator
  """
  readyCount: Int!

  """
  The datetime the phase is scheduled to be finished, null if no time limit or end time is set
  """
  scheduledEndTime: DateTime

  """
  The suggested ending datetime for a phase to be completed async, null if not enough data to make a suggestion
  """
  suggestedEndTime: DateTime

  """
  The suggested time limit for a phase to be completed together, null if not enough data to make a suggestion
  """
  suggestedTimeLimit: Float
  teamId: ID!

  """
  The number of milliseconds left before the scheduled end time. Useful for unsynced client clocks. null if scheduledEndTime is null
  """
  timeRemaining: Float
}

"""
The team-specific templates for sprint poker meeting
"""
type PokerTemplate implements MeetingTemplate {
  """
  shortid
  """
  id: ID!
  createdAt: DateTime!

  """
  True if template can be used, else false
  """
  isActive: Boolean!

  """
  The time of the meeting the template was last used
  """
  lastUsedAt: DateTime

  """
  The name of the template
  """
  name: String!

  """
  *Foreign key. The organization that owns the team that created the template
  """
  orgId: ID!

  """
  Who can see this template
  """
  scope: SharingScopeEnum!

  """
  *Foreign key. The team this template belongs to
  """
  teamId: ID!

  """
  The team this template belongs to
  """
  team: Team!

  """
  The type of the template
  """
  type: MeetingTypeEnum!
  updatedAt: DateTime!

  """
  The dimensions that are part of this template
  """
  dimensions: [TemplateDimension!]!

  """
  A query for the dimension
  """
  dimension(
    """
    The dimension ID for the desired dimension
    """
    dimensionId: ID!
  ): TemplateDimension!
}

"""
A meeting template that can be shared across team, orgnization and public
"""
interface MeetingTemplate {
  """
  shortid
  """
  id: ID!
  createdAt: DateTime!

  """
  True if template can be used, else false
  """
  isActive: Boolean!

  """
  The time of the meeting the template was last used
  """
  lastUsedAt: DateTime

  """
  The name of the template
  """
  name: String!

  """
  *Foreign key. The organization that owns the team that created the template
  """
  orgId: ID!

  """
  Who can see this template
  """
  scope: SharingScopeEnum!

  """
  *Foreign key. The team this template belongs to
  """
  teamId: ID!

  """
  The team this template belongs to
  """
  team: Team!

  """
  The type of the template
  """
  type: MeetingTypeEnum!
  updatedAt: DateTime!
}

"""
The meeting phase where all team members discuss the topics with the most votes
"""
type DiscussPhase implements NewMeetingPhase {
  """
  shortid
  """
  id: ID!
  meetingId: ID!
  teamId: ID!

  """
  The type of phase
  """
  phaseType: NewMeetingPhaseTypeEnum!
  stages: [RetroDiscussStage!]!
}

"""
The stage where the team discusses a single theme
"""
type RetroDiscussStage implements NewMeetingStage & DiscussionThreadStage {
  """
  stageId, shortid
  """
  id: ID!

  """
  The datetime the stage was completed
  """
  endAt: DateTime

  """
  foreign key. try using meeting
  """
  meetingId: ID!

  """
  The meeting this stage belongs to
  """
  meeting: NewMeeting

  """
  true if the facilitator has completed this stage, else false. Should be boolean(endAt)
  """
  isComplete: Boolean!

  """
  true if any meeting participant can navigate to this stage
  """
  isNavigable: Boolean!

  """
  true if the facilitator can navigate to this stage
  """
  isNavigableByFacilitator: Boolean!

  """
  The phase this stage belongs to
  """
  phase: NewMeetingPhase

  """
  The type of the phase
  """
  phaseType: NewMeetingPhaseTypeEnum

  """
  The datetime the stage was started
  """
  startAt: DateTime

  """
  Number of times the facilitator has visited this stage
  """
  viewCount: Int

  """
  true if a time limit is set, false if end time is set, null if neither is set
  """
  isAsync: Boolean

  """
  true if the viewer is ready to advance, else false
  """
  isViewerReady: Boolean!

  """
  the number of meeting members ready to advance, excluding the facilitator
  """
  readyCount: Int!

  """
  The datetime the phase is scheduled to be finished, null if no time limit or end time is set
  """
  scheduledEndTime: DateTime

  """
  The suggested ending datetime for a phase to be completed async, null if not enough data to make a suggestion
  """
  suggestedEndTime: DateTime

  """
  The suggested time limit for a phase to be completed together, null if not enough data to make a suggestion
  """
  suggestedTimeLimit: Float
  teamId: ID!

  """
  The number of milliseconds left before the scheduled end time. Useful for unsynced client clocks. null if scheduledEndTime is null
  """
  timeRemaining: Float

  """
  The ID to find the discussion that goes in the stage
  """
  discussionId: ID!

  """
  The discussion about the stage or a dummy data when there is no disscussion
  """
  discussion: Discussion!

  """
  foreign key. use reflectionGroup
  """
  reflectionGroupId: ID!

  """
  the group that is the focal point of the discussion
  """
  reflectionGroup: RetroReflectionGroup!

  """
  The sort order for reprioritizing discussion topics
  """
  sortOrder: Float!
}

"""
A meeting stage that includes a discussion thread
"""
interface DiscussionThreadStage {
  """
  The ID to find the discussion that goes in the stage
  """
  discussionId: ID!

  """
  The discussion about the stage
  """
  discussion: Discussion!
}

"""
The meeting phase where all team members give updates one-by-one
"""
type UpdatesPhase implements NewMeetingPhase {
  """
  shortid
  """
  id: ID!
  meetingId: ID!
  teamId: ID!

  """
  The type of phase
  """
  phaseType: NewMeetingPhaseTypeEnum!
  stages: [UpdatesStage!]!
}

"""
A stage that focuses on a single team member
"""
type UpdatesStage implements NewMeetingStage & NewMeetingTeamMemberStage {
  """
  stageId, shortid
  """
  id: ID!

  """
  The datetime the stage was completed
  """
  endAt: DateTime

  """
  foreign key. try using meeting
  """
  meetingId: ID!

  """
  The meeting this stage belongs to
  """
  meeting: NewMeeting

  """
  true if the facilitator has completed this stage, else false. Should be boolean(endAt)
  """
  isComplete: Boolean!

  """
  true if any meeting participant can navigate to this stage
  """
  isNavigable: Boolean!

  """
  true if the facilitator can navigate to this stage
  """
  isNavigableByFacilitator: Boolean!

  """
  The phase this stage belongs to
  """
  phase: NewMeetingPhase

  """
  The type of the phase
  """
  phaseType: NewMeetingPhaseTypeEnum

  """
  The datetime the stage was started
  """
  startAt: DateTime

  """
  Number of times the facilitator has visited this stage
  """
  viewCount: Int

  """
  true if a time limit is set, false if end time is set, null if neither is set
  """
  isAsync: Boolean

  """
  true if the viewer is ready to advance, else false
  """
  isViewerReady: Boolean!

  """
  the number of meeting members ready to advance, excluding the facilitator
  """
  readyCount: Int!

  """
  The datetime the phase is scheduled to be finished, null if no time limit or end time is set
  """
  scheduledEndTime: DateTime

  """
  The suggested ending datetime for a phase to be completed async, null if not enough data to make a suggestion
  """
  suggestedEndTime: DateTime

  """
  The suggested time limit for a phase to be completed together, null if not enough data to make a suggestion
  """
  suggestedTimeLimit: Float
  teamId: ID!

  """
  The number of milliseconds left before the scheduled end time. Useful for unsynced client clocks. null if scheduledEndTime is null
  """
  timeRemaining: Float

  """
  The meeting member that is the focus for this phase item
  """
  meetingMember: MeetingMember!

  """
  foreign key. use teamMember
  """
  teamMemberId: ID!

  """
  The team member that is the focus for this phase item
  """
  teamMember: TeamMember!
}

"""
The stage where the team estimates & discusses a single task
"""
type EstimateStage implements NewMeetingStage & DiscussionThreadStage {
  """
  stageId, shortid
  """
  id: ID!

  """
  The datetime the stage was completed
  """
  endAt: DateTime

  """
  foreign key. try using meeting
  """
  meetingId: ID!

  """
  The meeting this stage belongs to
  """
  meeting: NewMeeting

  """
  true if the facilitator has completed this stage, else false. Should be boolean(endAt)
  """
  isComplete: Boolean!

  """
  true if any meeting participant can navigate to this stage
  """
  isNavigable: Boolean!

  """
  true if the facilitator can navigate to this stage
  """
  isNavigableByFacilitator: Boolean!

  """
  The phase this stage belongs to
  """
  phase: NewMeetingPhase

  """
  The type of the phase
  """
  phaseType: NewMeetingPhaseTypeEnum

  """
  The datetime the stage was started
  """
  startAt: DateTime

  """
  Number of times the facilitator has visited this stage
  """
  viewCount: Int

  """
  true if a time limit is set, false if end time is set, null if neither is set
  """
  isAsync: Boolean

  """
  true if the viewer is ready to advance, else false
  """
  isViewerReady: Boolean!

  """
  the number of meeting members ready to advance, excluding the facilitator
  """
  readyCount: Int!

  """
  The datetime the phase is scheduled to be finished, null if no time limit or end time is set
  """
  scheduledEndTime: DateTime

  """
  The suggested ending datetime for a phase to be completed async, null if not enough data to make a suggestion
  """
  suggestedEndTime: DateTime

  """
  The suggested time limit for a phase to be completed together, null if not enough data to make a suggestion
  """
  suggestedTimeLimit: Float
  teamId: ID!

  """
  The number of milliseconds left before the scheduled end time. Useful for unsynced client clocks. null if scheduledEndTime is null
  """
  timeRemaining: Float

  """
  The ID to find the discussion that goes in the stage
  """
  discussionId: ID!

  """
  The discussion about the stage
  """
  discussion: Discussion!

  """
  The id of the user that added this stage.
  """
  creatorUserId: ID!

  """
  The ID that points to the issue that exists in parabol
  """
  taskId: ID!

  """
  The field name used by the service for this dimension
  """
  serviceField: ServiceField!

  """
  The immutable index of the dimensionRef tied to this stage
  """
  dimensionRefIdx: Int!

  """
  The immutable dimension linked to this stage
  """
  dimensionRef: TemplateDimensionRef!

  """
  the final score, as defined by the facilitator
  """
  finalScore: String

  """
  the userIds of the team members hovering the deck
  """
  hoveringUserIds: [ID!]!

  """
  the users of the team members hovering the deck
  """
  hoveringUsers: [User!]!

  """
  all the estimates, 1 per user
  """
  scores: [EstimateUserScore!]!

  """
  The task referenced in the stage, as it exists in Parabol. null if the task was deleted
  """
  task: Task

  """
  true when the participants are still voting and results are hidden. false when votes are revealed
  """
  isVoting: Boolean!
}

"""
A field that exists on a 3rd party service
"""
type ServiceField {
  """
  The name of the field as provided by the service
  """
  name: String!

  """
  The field type, to be used for validation and analytics
  """
  type: String!
}

"""
An immutable TemplateDimension
"""
type TemplateDimensionRef {
  id: ID!

  """
  the order of the dimensions in the template
  """
  sortOrder: Float!

  """
  The name of the dimension
  """
  name: String!

  """
  The md5 hash to resolve the immutable selected scale ref
  """
  scaleRefId: ID!

  """
  scale used in this dimension
  """
  scale: TemplateScaleRef!
}

"""
An immutable version of TemplateScale to be shared across all users
"""
type TemplateScaleRef {
  """
  md5 hash
  """
  id: ID!
  createdAt: DateTime!

  """
  The title of the scale used in the template
  """
  name: String!

  """
  The values used in this scale
  """
  values: [TemplateScaleValue!]!
}

"""
The user and number of points they estimated for dimension (where 1 stage has 1 dimension)
"""
type EstimateUserScore {
  """
  shortid
  """
  id: ID!

  """
  The stageId
  """
  stageId: ID!

  """
  The userId that for this score
  """
  userId: ID!

  """
  The user that for this score
  """
  user: User!

  """
  The label that was associated with the score at the time of the vote. Note: It may no longer exist on the dimension
  """
  label: String!
}

"""
The meeting phase where all team members discuss the topics with the most votes
"""
type AgendaItemsPhase implements NewMeetingPhase {
  """
  shortid
  """
  id: ID!
  meetingId: ID!
  teamId: ID!

  """
  The type of phase
  """
  phaseType: NewMeetingPhaseTypeEnum!
  stages: [AgendaItemsStage!]!
}

"""
The stage where the team discusses a single agenda item
"""
type AgendaItemsStage implements NewMeetingStage & DiscussionThreadStage {
  """
  stageId, shortid
  """
  id: ID!

  """
  The datetime the stage was completed
  """
  endAt: DateTime

  """
  foreign key. try using meeting
  """
  meetingId: ID!

  """
  The meeting this stage belongs to
  """
  meeting: NewMeeting

  """
  true if the facilitator has completed this stage, else false. Should be boolean(endAt)
  """
  isComplete: Boolean!

  """
  true if any meeting participant can navigate to this stage
  """
  isNavigable: Boolean!

  """
  true if the facilitator can navigate to this stage
  """
  isNavigableByFacilitator: Boolean!

  """
  The phase this stage belongs to
  """
  phase: NewMeetingPhase

  """
  The type of the phase
  """
  phaseType: NewMeetingPhaseTypeEnum

  """
  The datetime the stage was started
  """
  startAt: DateTime

  """
  Number of times the facilitator has visited this stage
  """
  viewCount: Int

  """
  true if a time limit is set, false if end time is set, null if neither is set
  """
  isAsync: Boolean

  """
  true if the viewer is ready to advance, else false
  """
  isViewerReady: Boolean!

  """
  the number of meeting members ready to advance, excluding the facilitator
  """
  readyCount: Int!

  """
  The datetime the phase is scheduled to be finished, null if no time limit or end time is set
  """
  scheduledEndTime: DateTime

  """
  The suggested ending datetime for a phase to be completed async, null if not enough data to make a suggestion
  """
  suggestedEndTime: DateTime

  """
  The suggested time limit for a phase to be completed together, null if not enough data to make a suggestion
  """
  suggestedTimeLimit: Float
  teamId: ID!

  """
  The number of milliseconds left before the scheduled end time. Useful for unsynced client clocks. null if scheduledEndTime is null
  """
  timeRemaining: Float

  """
  The ID to find the discussion that goes in the stage
  """
  discussionId: ID!

  """
  The discussion about the stage
  """
  discussion: Discussion!

  """
  The id of the agenda item this relates to
  """
  agendaItemId: ID!
  agendaItem: AgendaItem!
}

"""
An all-purpose meeting phase with no extra state
"""
type GenericMeetingPhase implements NewMeetingPhase {
  """
  shortid
  """
  id: ID!
  meetingId: ID!
  teamId: ID!

  """
  The type of phase
  """
  phaseType: NewMeetingPhaseTypeEnum!
  stages: [GenericMeetingStage!]!
}

"""
The meeting phase where all team members estimate a the point value of a task
"""
type EstimatePhase implements NewMeetingPhase {
  """
  shortid
  """
  id: ID!
  meetingId: ID!
  teamId: ID!

  """
  The type of phase
  """
  phaseType: NewMeetingPhaseTypeEnum!
  stages: [EstimateStage!]!
}

"""
A notification sent to a user that was invited to a new team
"""
type NotificationTeamInvitation implements Notification & TeamNotification {
  """
  FK
  """
  teamId: ID!

  """
  FK
  """
  invitationId: ID!

  """
  The invitation that triggered this notification
  """
  invitation: TeamInvitation!
  team: Team!

  """
  A shortid for the notification
  """
  id: ID!

  """
  UNREAD if new, READ if viewer has seen it, CLICKED if viewed clicked it
  """
  status: NotificationStatusEnum!

  """
  The datetime to activate the notification & send it to the client
  """
  createdAt: DateTime!
  type: NotificationEnum!

  """
  *The userId that should see this notification
  """
  userId: ID!
}

interface TeamNotification {
  id: ID
  type: NotificationEnum
}

"""
A notification alerting the user that they have been promoted (to team or org leader)
"""
type NotifyPromoteToOrgLeader implements Notification {
  organization: Organization!

  """
  A shortid for the notification
  """
  id: ID!

  """
  UNREAD if new, READ if viewer has seen it, CLICKED if viewed clicked it
  """
  status: NotificationStatusEnum!

  """
  The datetime to activate the notification & send it to the client
  """
  createdAt: DateTime!
  type: NotificationEnum!

  """
  *The userId that should see this notification
  """
  userId: ID!
}

"""
An action meeting
"""
type ActionMeeting implements NewMeeting {
  """
  The unique meeting id. shortid.
  """
  id: ID!

  """
  The timestamp the meeting was created
  """
  createdAt: DateTime!

  """
  The id of the user that created the meeting
  """
  createdBy: ID!

  """
  The user that created the meeting
  """
  createdByUser: User!

  """
  The timestamp the meeting officially ended
  """
  endedAt: DateTime

  """
  The location of the facilitator in the meeting
  """
  facilitatorStageId: ID!

  """
  The userId (or anonymousId) of the most recent facilitator
  """
  facilitatorUserId: ID!

  """
  The facilitator team member
  """
  facilitator: TeamMember!

  """
  The team members that were active during the time of the meeting
  """
  meetingMembers: [ActionMeetingMember!]!

  """
  The auto-incrementing meeting number for the team
  """
  meetingNumber: Int!
  meetingType: MeetingTypeEnum!

  """
  The name of the meeting
  """
  name: String!

  """
  The organization this meeting belongs to
  """
  organization: Organization!

  """
  The phases the meeting will go through, including all phase-specific state
  """
  phases: [NewMeetingPhase!]!

  """
  true if should show the org the conversion modal, else false
  """
  showConversionModal: Boolean!

  """
  The time the meeting summary was emailed to the team
  """
  summarySentAt: DateTime

  """
  foreign key for team
  """
  teamId: ID!

  """
  The team that ran the meeting
  """
  team: Team!

  """
  The last time a meeting was updated (stage completed, finished, etc)
  """
  updatedAt: DateTime

  """
  The action meeting member of the viewer
  """
  viewerMeetingMember: ActionMeetingMember

  """
  A single agenda item
  """
  agendaItem(agendaItemId: ID!): AgendaItem

  """
  The number of agenda items generated in the meeting
  """
  agendaItemCount: Int!

  """
  All of the agenda items for the meeting
  """
  agendaItems: [AgendaItem!]!

  """
  The number of comments generated in the meeting
  """
  commentCount: Int!

  """
  The settings that govern the action meeting
  """
  settings: ActionMeetingSettings!

  """
  The number of tasks generated in the meeting
  """
  taskCount: Int!

  """
  The tasks created within the meeting
  """
  tasks: [Task!]!
}

"""
All the meeting specifics for a user in a action meeting
"""
type ActionMeetingMember implements MeetingMember {
  """
  A composite of userId::meetingId
  """
  id: ID!

  """
  true if present, false if absent, else null
  """
  isCheckedIn: Boolean
    @deprecated(
      reason: "Members are checked in when they enter the meeting now & not created beforehand"
    )
  meetingId: ID!
  meetingType: MeetingTypeEnum!
  teamId: ID!
  teamMember: TeamMember!
  user: User!
  userId: ID!

  """
  The last time a meeting was updated (stage completed, finished, etc)
  """
  updatedAt: DateTime!

  """
  The tasks marked as done in the meeting
  """
  doneTasks: [Task!]!

  """
  The tasks assigned to members during the meeting
  """
  tasks: [Task!]!
}

"""
The retro-specific meeting settings
"""
type PokerMeetingSettings implements TeamMeetingSettings {
  id: ID!

  """
  The type of meeting these settings apply to
  """
  meetingType: MeetingTypeEnum!

  """
  The broad phase types that will be addressed during the meeting
  """
  phaseTypes: [NewMeetingPhaseTypeEnum!]!

  """
  FK
  """
  teamId: ID!

  """
  The team these settings belong to
  """
  team: Team!

  """
  FK. The template that will be used to start the poker meeting
  """
  selectedTemplateId: ID!

  """
  The template that will be used to start the Poker meeting
  """
  selectedTemplate: PokerTemplate!

  """
  The list of templates used to start a Poker meeting
  """
  teamTemplates: [PokerTemplate!]!

  """
  The list of templates shared across the organization to start a Poker meeting
  """
  organizationTemplates(
    first: Int!

    """
    The cursor, which is the templateId
    """
    after: ID
  ): PokerTemplateConnection!

  """
  The list of templates shared across the organization to start a Poker meeting
  """
  publicTemplates(
    first: Int!

    """
    The cursor, which is the templateId
    """
    after: ID
  ): PokerTemplateConnection!
}

"""
A connection to a list of items.
"""
type PokerTemplateConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [PokerTemplateEdge!]!
}

"""
An edge in a connection.
"""
type PokerTemplateEdge {
  """
  The item at the end of the edge
  """
  node: PokerTemplate!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
A retrospective meeting
"""
type RetrospectiveMeeting implements NewMeeting {
  """
  The unique meeting id. shortid.
  """
  id: ID!

  """
  The timestamp the meeting was created
  """
  createdAt: DateTime!

  """
  The id of the user that created the meeting
  """
  createdBy: ID!

  """
  The user that created the meeting
  """
  createdByUser: User!

  """
  The timestamp the meeting officially ended
  """
  endedAt: DateTime

  """
  The location of the facilitator in the meeting
  """
  facilitatorStageId: ID!

  """
  The userId (or anonymousId) of the most recent facilitator
  """
  facilitatorUserId: ID!

  """
  The facilitator team member
  """
  facilitator: TeamMember!

  """
  The team members that were active during the time of the meeting
  """
  meetingMembers: [RetrospectiveMeetingMember!]!

  """
  The auto-incrementing meeting number for the team
  """
  meetingNumber: Int!
  meetingType: MeetingTypeEnum!

  """
  The name of the meeting
  """
  name: String!

  """
  The organization this meeting belongs to
  """
  organization: Organization!

  """
  The phases the meeting will go through, including all phase-specific state
  """
  phases: [NewMeetingPhase!]!

  """
  true if should show the org the conversion modal, else false
  """
  showConversionModal: Boolean!

  """
  The time the meeting summary was emailed to the team
  """
  summarySentAt: DateTime
  teamId: ID!

  """
  The team that ran the meeting
  """
  team: Team!

  """
  The last time a meeting was updated (stage completed, finished, etc)
  """
  updatedAt: DateTime

  """
  The retrospective meeting member of the viewer
  """
  viewerMeetingMember: RetrospectiveMeetingMember

  """
  the threshold used to achieve the autogroup. Useful for model tuning. Serves as a flag if autogroup was used.
  """
  autoGroupThreshold: Float

  """
  The number of comments generated in the meeting
  """
  commentCount: Int!

  """
  the number of votes allowed for each participant to cast on a single group
  """
  maxVotesPerGroup: Int!

  """
  the next smallest distance threshold to guarantee at least 1 more grouping will be achieved
  """
  nextAutoGroupThreshold: Float

  """
  The number of reflections generated in the meeting
  """
  reflectionCount: Int!

  """
  a single reflection group
  """
  reflectionGroup(reflectionGroupId: ID!): RetroReflectionGroup

  """
  The grouped reflections
  """
  reflectionGroups(sortBy: ReflectionGroupSortEnum): [RetroReflectionGroup!]!

  """
  The settings that govern the retrospective meeting
  """
  settings: RetrospectiveMeetingSettings!

  """
  The number of tasks generated in the meeting
  """
  taskCount: Int!

  """
  The tasks created within the meeting
  """
  tasks: [Task!]!

  """
  The ID of the template used for the meeting
  """
  templateId: ID!

  """
  The number of topics generated in the meeting
  """
  topicCount: Int!

  """
  the total number of votes allowed for each participant
  """
  totalVotes: Int!

  """
  The sum total of the votes remaining for the meeting members that are present in the meeting
  """
  votesRemaining: Int!
}

"""
sorts for the reflection group. default is sortOrder. sorting by voteCount filters out items without votes.
"""
enum ReflectionGroupSortEnum {
  voteCount
  stageOrder
}

"""
All the meeting specifics for a user in a retro meeting
"""
type RetrospectiveMeetingMember implements MeetingMember {
  """
  A composite of userId::meetingId
  """
  id: ID!

  """
  true if present, false if absent, else null
  """
  isCheckedIn: Boolean
    @deprecated(
      reason: "Members are checked in when they enter the meeting now & not created beforehand"
    )
  meetingId: ID!
  meetingType: MeetingTypeEnum!
  teamId: ID!
  teamMember: TeamMember!
  user: User!
  userId: ID!

  """
  The last time a meeting was updated (stage completed, finished, etc)
  """
  updatedAt: DateTime!

  """
  The tasks assigned to members during the meeting
  """
  tasks: [Task!]!
  votesRemaining: Int!
}

"""
The retro-specific meeting settings
"""
type RetrospectiveMeetingSettings implements TeamMeetingSettings {
  id: ID!

  """
  The type of meeting these settings apply to
  """
  meetingType: MeetingTypeEnum!

  """
  The broad phase types that will be addressed during the meeting
  """
  phaseTypes: [NewMeetingPhaseTypeEnum!]!

  """
  FK
  """
  teamId: ID!

  """
  The team these settings belong to
  """
  team: Team!

  """
  The total number of votes each team member receives for the voting phase
  """
  totalVotes: Int!

  """
  The maximum number of votes a team member can vote for a single reflection group
  """
  maxVotesPerGroup: Int!

  """
  FK. The template that will be used to start the retrospective
  """
  selectedTemplateId: ID!

  """
  The template that will be used to start the retrospective
  """
  selectedTemplate: ReflectTemplate!

  """
  The list of templates used to start a retrospective
  """
  reflectTemplates: [ReflectTemplate!]!

  """
  The list of templates used to start a retrospective
  """
  teamTemplates: [ReflectTemplate!]!

  """
  The list of templates shared across the organization to start a retrospective
  """
  organizationTemplates(
    first: Int!

    """
    The cursor, which is the templateId
    """
    after: ID
  ): ReflectTemplateConnection!

  """
  The list of templates shared across the organization to start a retrospective
  """
  publicTemplates(
    first: Int!

    """
    The cursor, which is the templateId
    """
    after: ID
  ): ReflectTemplateConnection!
}

"""
A connection to a list of items.
"""
type ReflectTemplateConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [ReflectTemplateEdge!]!
}

"""
An edge in a connection.
"""
type ReflectTemplateEdge {
  """
  The item at the end of the edge
  """
  node: ReflectTemplate!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
a suggestion to invite others to your team
"""
type SuggestedActionInviteYourTeam implements SuggestedAction {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the action was created at
  """
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """
  * The timestamp the action was removed at
  """
  removedAt: DateTime!

  """
  The specific type of suggested action
  """
  type: SuggestedActionTypeEnum!

  """
  * The userId this action is for
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!

  """
  The teamId that we suggest you should invite people to
  """
  teamId: ID!

  """
  The team you should invite people to
  """
  team: Team!
}

"""
a suggestion to try a retro with your team
"""
type SuggestedActionTryRetroMeeting implements SuggestedAction {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the action was created at
  """
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """
  * The timestamp the action was removed at
  """
  removedAt: DateTime!

  """
  The specific type of suggested action
  """
  type: SuggestedActionTypeEnum!

  """
  * The userId this action is for
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!

  """
  fk
  """
  teamId: ID!

  """
  The team you should run a retro with
  """
  team: Team!
}

"""
a suggestion to try a retro with your team
"""
type SuggestedActionTryActionMeeting implements SuggestedAction {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the action was created at
  """
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """
  * The timestamp the action was removed at
  """
  removedAt: DateTime!

  """
  The specific type of suggested action
  """
  type: SuggestedActionTypeEnum!

  """
  * The userId this action is for
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!

  """
  fk
  """
  teamId: ID!

  """
  The team you should run an action meeting with
  """
  team: Team!
}

"""
a suggestion to try a retro with your team
"""
type SuggestedActionCreateNewTeam implements SuggestedAction {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the action was created at
  """
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """
  * The timestamp the action was removed at
  """
  removedAt: DateTime!

  """
  The specific type of suggested action
  """
  type: SuggestedActionTypeEnum!

  """
  * The userId this action is for
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!
}

"""
a suggestion to invite others to your team
"""
type SuggestedActionTryTheDemo implements SuggestedAction {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the action was created at
  """
  createdAt: DateTime!

  """
  The priority of the suggested action compared to other suggested actions (smaller number is higher priority)
  """
  priority: Float

  """
  * The timestamp the action was removed at
  """
  removedAt: DateTime!

  """
  The specific type of suggested action
  """
  type: SuggestedActionTypeEnum!

  """
  * The userId this action is for
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!
}

"""
An event triggered whenever a team is created
"""
type TimelineEventTeamCreated implements TimelineEvent {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the event was created at
  """
  createdAt: DateTime!

  """
  the number of times the user has interacted with (ie clicked) this event
  """
  interactionCount: Int!

  """
  true if the timeline event is active, false if archived
  """
  isActive: Boolean!

  """
  The orgId this event is associated with
  """
  orgId: ID!

  """
  The organization this event is associated with
  """
  organization: Organization

  """
  the number of times the user has seen this event
  """
  seenCount: Int!

  """
  The teamId this event is associated with. Null if not traceable to one team
  """
  teamId: ID!

  """
  The team that can see this event
  """
  team: Team!

  """
  The specific type of event
  """
  type: TimelineEventEnum!

  """
  * The userId that can see this event
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!
}

"""
An event for joining the app
"""
type TimelineEventJoinedParabol implements TimelineEvent {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the event was created at
  """
  createdAt: DateTime!

  """
  the number of times the user has interacted with (ie clicked) this event
  """
  interactionCount: Int!

  """
  true if the timeline event is active, false if archived
  """
  isActive: Boolean!

  """
  The orgId this event is associated with. Null if not traceable to one org
  """
  orgId: ID

  """
  The organization this event is associated with
  """
  organization: Organization

  """
  the number of times the user has seen this event
  """
  seenCount: Int!

  """
  The teamId this event is associated with. Null if not traceable to one team
  """
  teamId: ID

  """
  The team that can see this event
  """
  team: Team

  """
  The specific type of event
  """
  type: TimelineEventEnum!

  """
  * The userId that can see this event
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!
}

"""
An event for a completed retro meeting
"""
type TimelineEventCompletedRetroMeeting implements TimelineEvent {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the event was created at
  """
  createdAt: DateTime!

  """
  the number of times the user has interacted with (ie clicked) this event
  """
  interactionCount: Int!

  """
  true if the timeline event is active, false if archived
  """
  isActive: Boolean!

  """
  The orgId this event is associated with
  """
  orgId: ID!

  """
  The organization this event is associated with
  """
  organization: Organization

  """
  the number of times the user has seen this event
  """
  seenCount: Int!

  """
  The teamId this event is associated with
  """
  teamId: ID!

  """
  The team that can see this event
  """
  team: Team!

  """
  The specific type of event
  """
  type: TimelineEventEnum!

  """
  * The userId that can see this event
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!

  """
  The meeting that was completed
  """
  meeting: RetrospectiveMeeting!

  """
  The meetingId that was completed
  """
  meetingId: ID!
}

"""
An event for a completed action meeting
"""
type TimelineEventCompletedActionMeeting implements TimelineEvent {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the event was created at
  """
  createdAt: DateTime!

  """
  the number of times the user has interacted with (ie clicked) this event
  """
  interactionCount: Int!

  """
  true if the timeline event is active, false if archived
  """
  isActive: Boolean!

  """
  The orgId this event is associated with
  """
  orgId: ID!

  """
  The organization this event is associated with
  """
  organization: Organization

  """
  the number of times the user has seen this event
  """
  seenCount: Int!

  """
  The teamId this event is associated with
  """
  teamId: ID!

  """
  The team that can see this event
  """
  team: Team!

  """
  The specific type of event
  """
  type: TimelineEventEnum!

  """
  * The userId that can see this event
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!

  """
  The meeting that was completed
  """
  meeting: ActionMeeting!

  """
  The meetingId that was completed, null if legacyMeetingId is present
  """
  meetingId: ID!
}

"""
An event for a completed poker meeting
"""
type TimelineEventPokerComplete implements TimelineEvent {
  """
  shortid
  """
  id: ID!

  """
  * The timestamp the event was created at
  """
  createdAt: DateTime!

  """
  the number of times the user has interacted with (ie clicked) this event
  """
  interactionCount: Int!

  """
  true if the timeline event is active, false if archived
  """
  isActive: Boolean!

  """
  The orgId this event is associated with
  """
  orgId: ID!

  """
  The organization this event is associated with
  """
  organization: Organization

  """
  the number of times the user has seen this event
  """
  seenCount: Int!

  """
  The teamId this event is associated with
  """
  teamId: ID!

  """
  The team that can see this event
  """
  team: Team!

  """
  The specific type of event
  """
  type: TimelineEventEnum!

  """
  * The userId that can see this event
  """
  userId: ID!

  """
  The user than can see this event
  """
  user: User!

  """
  The meeting that was completed
  """
  meeting: PokerMeeting!

  """
  The meetingId that was completed
  """
  meetingId: ID!
}

"""
A Poker meeting
"""
type PokerMeeting implements NewMeeting {
  """
  The unique meeting id. shortid.
  """
  id: ID!

  """
  The timestamp the meeting was created
  """
  createdAt: DateTime!

  """
  The id of the user that created the meeting
  """
  createdBy: ID!

  """
  The user that created the meeting
  """
  createdByUser: User!

  """
  The timestamp the meeting officially ended
  """
  endedAt: DateTime

  """
  The location of the facilitator in the meeting
  """
  facilitatorStageId: ID!

  """
  The userId (or anonymousId) of the most recent facilitator
  """
  facilitatorUserId: ID!

  """
  The facilitator team member
  """
  facilitator: TeamMember!

  """
  The team members that were active during the time of the meeting
  """
  meetingMembers: [PokerMeetingMember!]!

  """
  The auto-incrementing meeting number for the team
  """
  meetingNumber: Int!
  meetingType: MeetingTypeEnum!

  """
  The name of the meeting
  """
  name: String!

  """
  The organization this meeting belongs to
  """
  organization: Organization!

  """
  The phases the meeting will go through, including all phase-specific state
  """
  phases: [NewMeetingPhase!]!

  """
  true if should show the org the conversion modal, else false
  """
  showConversionModal: Boolean!

  """
  The time the meeting summary was emailed to the team
  """
  summarySentAt: DateTime
  teamId: ID!

  """
  The team that ran the meeting
  """
  team: Team!

  """
  The last time a meeting was updated (stage completed, finished, etc)
  """
  updatedAt: DateTime

  """
  The Poker meeting member of the viewer
  """
  viewerMeetingMember: PokerMeetingMember

  """
  The number of comments generated in the meeting
  """
  commentCount: Int!

  """
  The number of stories scored during a meeting
  """
  storyCount: Int!

  """
  The settings that govern the Poker meeting
  """
  settings: PokerMeetingSettings!

  """
  A single story created in a Sprint Poker meeting
  """
  story(storyId: ID!): Task

  """
  The ID of the template used for the meeting. Note the underlying template could have changed!
  """
  templateId: ID! @deprecated(reason: "The underlying template could be mutated. Use templateRefId")

  """
  The ID of the immutable templateRef used for the meeting
  """
  templateRefId: ID!
}

"""
All the meeting specifics for a user in a poker meeting
"""
type PokerMeetingMember implements MeetingMember {
  """
  A composite of userId::meetingId
  """
  id: ID!

  """
  true if present, false if absent, else null
  """
  isCheckedIn: Boolean
    @deprecated(
      reason: "Members are checked in when they enter the meeting now & not created beforehand"
    )
  meetingId: ID!
  meetingType: MeetingTypeEnum!
  teamId: ID!
  teamMember: TeamMember!
  user: User!
  userId: ID!

  """
  The last time a meeting was updated (stage completed, finished, etc)
  """
  updatedAt: DateTime!

  """
  true if the user is not voting and does not want their vote to count towards aggregates
  """
  isSpectating: Boolean!
}

"""
The action-specific meeting settings
"""
type ActionMeetingSettings implements TeamMeetingSettings {
  id: ID!

  """
  The type of meeting these settings apply to
  """
  meetingType: MeetingTypeEnum!

  """
  The broad phase types that will be addressed during the meeting
  """
  phaseTypes: [NewMeetingPhaseTypeEnum!]!

  """
  FK
  """
  teamId: ID!

  """
  The team these settings belong to
  """
  team: Team!
}

"""
A team prompt meeting
"""
type TeamPromptMeeting implements NewMeeting {
  """
  The unique meeting id. shortid.
  """
  id: ID!

  """
  The meeting series id this meeting is associated with if the meeting is recurring
  """
  meetingSeriesId: ID

  """
  The meeting series this meeting is associated with if the meeting is recurring
  """
  meetingSeries: MeetingSeries

  """
  The timestamp the meeting is scheduled to end
  """
  scheduledEndTime: DateTime

  """
  The timestamp the meeting was created
  """
  createdAt: DateTime!

  """
  The id of the user that created the meeting
  """
  createdBy: ID!

  """
  The user that created the meeting
  """
  createdByUser: User!

  """
  The timestamp the meeting officially ended
  """
  endedAt: DateTime

  """
  The location of the facilitator in the meeting
  """
  facilitatorStageId: ID!

  """
  The userId (or anonymousId) of the most recent facilitator
  """
  facilitatorUserId: ID!

  """
  The facilitator team member
  """
  facilitator: TeamMember!

  """
  The team members that were active during the time of the meeting
  """
  meetingMembers: [MeetingMember!]!

  """
  The auto-incrementing meeting number for the team
  """
  meetingNumber: Int!
  meetingType: MeetingTypeEnum!

  """
  The name of the meeting
  """
  name: String!

  """
  The organization this meeting belongs to
  """
  organization: Organization!

  """
  The phases the meeting will go through, including all phase-specific state
  """
  phases: [NewMeetingPhase!]!

  """
  true if should show the org the conversion modal, else false
  """
  showConversionModal: Boolean!

  """
  The time the meeting summary was emailed to the team
  """
  summarySentAt: DateTime

  """
  foreign key for team
  """
  teamId: ID!

  """
  The team that ran the meeting
  """
  team: Team!

  """
  The last time a meeting was updated (stage completed, finished, etc)
  """
  updatedAt: DateTime

  """
  The team prompt meeting member of the viewer
  """
  viewerMeetingMember: TeamPromptMeetingMember

  """
  The settings that govern the team prompt meeting
  """
  settings: TeamPromptMeetingSettings!

  """
  The tasks created within the meeting
  """
  responses: [TeamPromptResponse!]!
}

"""
All the meeting specifics for a user in a team prompt meeting
"""
type TeamPromptMeetingMember implements MeetingMember {
  """
  A composite of userId::meetingId
  """
  id: ID!

  """
  true if present, false if absent, else null
  """
  isCheckedIn: Boolean
    @deprecated(
      reason: "Members are checked in when they enter the meeting now & not created beforehand"
    )
  meetingId: ID!
  meetingType: MeetingTypeEnum!
  teamId: ID!
  teamMember: TeamMember!
  user: User!
  userId: ID!

  """
  The last time a meeting was updated (stage completed, finished, etc)
  """
  updatedAt: DateTime!
}

"""
The team prompt specific meeting settings
"""
type TeamPromptMeetingSettings implements TeamMeetingSettings {
  id: ID!

  """
  The type of meeting these settings apply to
  """
  meetingType: MeetingTypeEnum!

  """
  The broad phase types that will be addressed during the meeting
  """
  phaseTypes: [NewMeetingPhaseTypeEnum!]!

  """
  FK
  """
  teamId: ID!

  """
  The team these settings belong to
  """
  team: Team!
}

"""
A comment on a thread
"""
type Comment implements Reactable & Threadable {
  """
  shortid
  """
  id: ID!

  """
  The rich text body of the item, if inactive, a tombstone text
  """
  content: String!

  """
  The timestamp the item was created
  """
  createdAt: DateTime!

  """
  The userId that created the item, null if anonymous
  """
  createdBy: ID

  """
  The user that created the item, null if anonymous
  """
  createdByUser: User

  """
  the replies to this threadable item
  """
  replies: [Threadable!]!

  """
  The FK of the discussion this task was created in. Null if task was not created in a discussion
  """
  discussionId: ID

  """
  the parent, if this threadable is a reply, else null
  """
  threadParentId: ID

  """
  the order of this threadable, relative to threadParentId
  """
  threadSortOrder: Float

  """
  The timestamp the item was updated
  """
  updatedAt: DateTime!

  """
  All the reactjis for the given reflection
  """
  reactjis: [Reactji!]!

  """
  true if the agenda item has not been processed or deleted
  """
  isActive: Boolean!

  """
  true if the comment is anonymous, else false
  """
  isAnonymous: Boolean!

  """
  true if the viewer wrote this comment, else false
  """
  isViewerComment: Boolean!
}

type Query {
  viewer: User!
  getDemoEntities(
    """
    the reflection bodies to entitize
    """
    text: String!
  ): GetDemoEntitiesPayload!
  massInvitation(
    """
    The mass invitation token
    """
    token: ID!
  ): MassInvitationPayload!
  verifiedInvitation(
    """
    The invitation token
    """
    token: ID!
  ): VerifiedInvitationPayload!
  SAMLIdP(
    """
    the email associated with a SAML login
    """
    email: ID!

    """
    true if the user was invited, else false
    """
    isInvited: Boolean
  ): String
}

type GetDemoEntitiesPayload {
  error: StandardMutationError
  entities: [GoogleAnalyzedEntity!]
}

type MassInvitationPayload {
  errorType: TeamInvitationErrorEnum

  """
  The name of the person that sent the invitation, present if errorType is expired
  """
  inviterName: String

  """
  The teamId from the token
  """
  teamId: ID

  """
  name of the inviting team, present if invitation exists
  """
  teamName: String
}

type VerifiedInvitationPayload {
  errorType: TeamInvitationErrorEnum

  """
  The name of the person that sent the invitation, present if errorType is expired
  """
  inviterName: String

  """
  The email of the person that send the invitation, present if errorType is expired
  """
  inviterEmail: String

  """
  true if the mx record is hosted by google, else falsy
  """
  isGoogle: Boolean

  """
  a string to redirect to the sso IdP, else null
  """
  ssoURL: String

  """
  The valid invitation, if any
  """
  teamInvitation: TeamInvitation

  """
  name of the inviting team, present if invitation exists
  """
  teamName: String
  meetingId: ID
  meetingName: String
  meetingType: MeetingTypeEnum

  """
  The userId of the invitee, if already a parabol user
  """
  userId: ID

  """
  The invitee, if already a parabol user, present if errorType is null
  """
  user: User
}

type Mutation {
  """
  Create a new agenda item
  """
  addAgendaItem(
    """
    The new task including an id, teamMemberId, and content
    """
    newAgendaItem: CreateAgendaItemInput!
  ): AddAgendaItemPayload
  addAtlassianAuth(code: ID!, teamId: ID!): AddAtlassianAuthPayload!

  """
  Add a comment to a discussion
  """
  addComment(
    """
    A partial new comment
    """
    comment: AddCommentInput!
  ): AddCommentPayload!

  """
  Add a new poker template with a default dimension created
  """
  addPokerTemplate(parentTemplateId: ID, teamId: ID!): AddPokerTemplatePayload!

  """
  Add a new dimension for the poker template
  """
  addPokerTemplateDimension(templateId: ID!): AddPokerTemplateDimensionPayload!

  """
  Add a new scale for the poker template
  """
  addPokerTemplateScale(parentScaleId: ID, teamId: ID!): AddPokerTemplateScalePayload!

  """
  Add a new scale value for a scale in a poker template
  """
  addPokerTemplateScaleValue(
    scaleId: ID!
    scaleValue: AddTemplateScaleInput!
  ): AddPokerTemplateScaleValuePayload!

  """
  Add or remove a reactji from a reactable
  """
  addReactjiToReactable(
    """
    The id of the reactable
    """
    reactableId: ID!

    """
    the type of the
    """
    reactableType: ReactableEnum!

    """
    the id of the reactji to add
    """
    reactji: String!

    """
    If true, remove the reaction, else add it
    """
    isRemove: Boolean

    """
    The id of the meeting
    """
    meetingId: ID!
  ): AddReactjiToReactablePayload!

  """
  Add a new template full of prompts
  """
  addReflectTemplate(parentTemplateId: ID, teamId: ID!): AddReflectTemplatePayload

  """
  Add a new template full of prompts
  """
  addReflectTemplatePrompt(templateId: ID!): AddReflectTemplatePromptPayload
  addSlackAuth(code: ID!, teamId: ID!): AddSlackAuthPayload!

  addGitHubAuth(code: ID!, teamId: ID!): AddGitHubAuthPayload!

  """
  Create a new team and add the first team member
  """
  addOrg(
    """
    The new team object with exactly 1 team member
    """
    newTeam: NewTeamInput!

    """
    The name of the new team
    """
    orgName: String!
  ): AddOrgPayload!

  """
  Create a new team and add the first team member
  """
  addTeam(
    """
    The new team object
    """
    newTeam: NewTeamInput!
  ): AddTeamPayload!
  archiveOrganization(
    """
    The orgId to archive
    """
    orgId: ID!
  ): ArchiveOrganizationPayload!
  archiveTeam(
    """
    The teamId to archive (or delete, if team is unused)
    """
    teamId: ID!
  ): ArchiveTeamPayload!

  """
  Archive a timeline event
  """
  archiveTimelineEvent(
    """
    the id for the timeline event
    """
    timelineEventId: ID!
  ): ArchiveTimelineEventPayload!

  """
  Automatically group reflections
  """
  autoGroupReflections(
    meetingId: ID!

    """
    A number from 0 to 1 to determine how tightly to pack the groups. Higher means fewer groups
    """
    groupingThreshold: Float!
  ): AutoGroupReflectionsPayload

  """
  Change the team a task is associated with. Also copy the viewers integration if necessary.
  """
  changeTaskTeam(
    """
    The task to change
    """
    taskId: ID!

    """
    The new team to assign the task to
    """
    teamId: ID!
  ): ChangeTaskTeamPayload

  """
  set the interaction status of a notifcation
  """
  setNotificationStatus(
    """
    The id of the notification
    """
    notificationId: ID!
    status: NotificationStatusEnum!
  ): SetNotificationStatusPayload

  createTaskIntegration(
    """
    Which integration to push the task to
    """
    integrationProviderService: IntegrationProviderServiceEnum!

    """
    Jira projectId, GitHub nameWithOwner etc.
    """
    integrationRepoId: ID!

    """
    The id of the task to convert to an issue
    """
    taskId: ID!
  ): CreateTaskIntegrationPayload

  """
  Create a new mass inivtation and optionally void old ones
  """
  createMassInvitation(
    """
    the specific meeting where the invite occurred, if any
    """
    meetingId: ID

    """
    The teamId to create the mass invitation for
    """
    teamId: ID!

    """
    If true, will void all existing mass invitations for the team member
    """
    voidOld: Boolean
  ): CreateMassInvitationPayload!

  """
  Generate a new OAuth1 request token and encode it in the authorization URL to start an oauth1 flow
  """
  createOAuth1AuthorizeUrl(
    """
    Id of the integration provider with OAuth1 auth strategy
    """
    providerId: ID!

    """
    Id of the team where the integration should be added
    """
    teamId: ID!
  ): CreateOAuth1AuthorizationURLPayload

  """
  Create a new reflection
  """
  createReflection(input: CreateReflectionInput!): CreateReflectionPayload

  """
  Create a new task, triggering a CreateCard for other viewers
  """
  createTask(
    """
    The new task including an id, status, and type, and teamMemberId
    """
    newTask: CreateTaskInput!

    """
    The part of the site where the creation occurred
    """
    area: AreaEnum
  ): CreateTaskPayload!

  """
  Delete a comment from a discussion
  """
  deleteComment(commentId: ID!, meetingId: ID!): DeleteCommentPayload!

  """
  Delete (not archive!) a task
  """
  deleteTask(
    """
    The taskId to delete
    """
    taskId: ID!
  ): DeleteTaskPayload

  """
  Delete a user, removing them from all teams and orgs
  """
  deleteUser(
    """
    a userId
    """
    userId: ID

    """
    the user email
    """
    email: ID

    """
    the reason why the user wants to delete their account
    """
    reason: String
  ): DeleteUserPayload!

  """
  Deny a user from joining via push invitation
  """
  denyPushInvitation(teamId: ID!, userId: ID!): DenyPushInvitationPayload

  """
  Redeem an invitation token for a logged in user
  """
  dismissNewFeature: DismissNewFeaturePayload!

  """
  Dismiss a suggested action
  """
  dismissSuggestedAction(
    """
    The id of the suggested action to dismiss
    """
    suggestedActionId: ID!
  ): DismissSuggestedActionPayload!

  """
  Downgrade a paid account to the starter plan service
  """
  downgradeToStarter(
    """
    the org requesting the upgrade
    """
    orgId: ID!
  ): DowngradeToStarterPayload

  """
  Changes the priority of the discussion topics
  """
  dragDiscussionTopic(meetingId: ID!, stageId: ID!, sortOrder: Float!): DragDiscussionTopicPayload

  """
  Changes the ordering of the estimating tasks
  """
  dragEstimatingTask(
    meetingId: ID!
    taskId: ID!

    """
    The index of the tasks will be moved to, in the list of estimating tasks sidebar section
    """
    newPositionIndex: Int!
  ): DragEstimatingTaskPayload!

  """
  Send an email to reset a password
  """
  emailPasswordReset(
    """
    email to send the password reset code to
    """
    email: ID!
  ): EmailPasswordResetPayload!

  """
  Track which users are commenting
  """
  editCommenting(
    """
    True if the user is commenting, false if the user has stopped commenting
    """
    isCommenting: Boolean!
    discussionId: ID!
  ): EditCommentingPayload

  """
  Finish a sprint poker meeting
  """
  endSprintPoker(
    """
    The meeting to end
    """
    meetingId: ID!
  ): EndSprintPokerPayload!

  """
  Changes the editing state of a user for a phase item
  """
  editReflection(
    """
    Whether a reflectPrompt is being edited or not
    """
    isEditing: Boolean!
    meetingId: ID!
    promptId: ID!
  ): EditReflectionPayload

  """
  Announce to everyone that you are editing a task
  """
  editTask(
    """
    The task id that is being edited
    """
    taskId: ID!

    """
    true if the editing is starting, false if it is stopping
    """
    isEditing: Boolean!
  ): EditTaskPayload

  """
  Finish a check-in meeting
  """
  endCheckIn(
    """
    The meeting to end
    """
    meetingId: ID!
  ): EndCheckInPayload!

  """
  Broadcast that the viewer stopped dragging a reflection
  """
  endDraggingReflection(
    reflectionId: ID!

    """
    if it was a drop (isDragging = false), the type of item it was dropped on. null if there was no valid drop target
    """
    dropTargetType: DragReflectionDropTargetTypeEnum

    """
    if dropTargetType could refer to more than 1 component, this ID defines which one
    """
    dropTargetId: ID

    """
    the ID of the drag to connect to the start drag event
    """
    dragId: ID
  ): EndDraggingReflectionPayload

  """
  Finish a retrospective meeting
  """
  endRetrospective(
    """
    The meeting to end
    """
    meetingId: ID!
  ): EndRetrospectivePayload!

  """
  flag a viewer as ready to advance to the next stage of a meeting
  """
  flagReadyToAdvance(
    meetingId: ID!

    """
    the stage that the viewer marked as ready
    """
    stageId: ID!

    """
    true if ready to advance, else false
    """
    isReady: Boolean!
  ): FlagReadyToAdvancePayload!

  """
  pauses the subscription for a single user
  """
  inactivateUser(
    """
    the user to pause
    """
    userId: ID!
  ): InactivateUserPayload

  """
  Invalidate all sessions by blacklisting all JWTs issued before now
  """
  invalidateSessions: InvalidateSessionsPayload!

  """
  Send a team invitation to an email address
  """
  inviteToTeam(
    """
    the specific meeting where the invite occurred, if any
    """
    meetingId: ID

    """
    The id of the inviting team
    """
    teamId: ID!
    invitees: [Email!]!
  ): InviteToTeamPayload!

  """
  Login using an email address and password
  """
  loginWithPassword(email: ID!, password: String!): UserLogInPayload!

  """
  Move a template dimension
  """
  movePokerTemplateDimension(
    dimensionId: ID!
    sortOrder: Float!
  ): MovePokerTemplateDimensionPayload!

  """
  Move a reflect template
  """
  moveReflectTemplatePrompt(promptId: ID!, sortOrder: Float!): MoveReflectTemplatePromptPayload

  """
  Move a team to a different org. Requires billing leader rights on both orgs!
  """
  moveTeamToOrg(
    """
    The teamId that you want to move
    """
    teamIds: [ID!]!

    """
    The ID of the organization you want to move the team to
    """
    orgId: ID!
  ): String

  """
  update a meeting by marking an item complete and setting the facilitator location
  """
  navigateMeeting(
    """
    The stage that the facilitator would like to mark as complete
    """
    completedStageId: ID

    """
    The stage where the facilitator is
    """
    facilitatorStageId: ID

    """
    The meeting ID
    """
    meetingId: ID!
  ): NavigateMeetingPayload!

  """
  Check a member in as present or absent
  """
  newMeetingCheckIn(
    """
    The id of the user being marked present or absent
    """
    userId: ID!

    """
    the meeting currently in progress
    """
    meetingId: ID!

    """
    true if the member is present, false if absent, null if undecided
    """
    isCheckedIn: Boolean
  ): NewMeetingCheckInPayload
    @deprecated(reason: "Members now join lazily and joining means they are present")

  """
  Increment the count of times the org has clicked pay later
  """
  payLater(
    """
    the org that has clicked pay later
    """
    meetingId: ID!
  ): PayLaterPayload!

  """
  Add or remove a task and its estimate phase from the meeting
  """
  persistJiraSearchQuery(
    """
    the team with the settings we add the query to
    """
    teamId: ID!

    """
    the jira search query to persist (or remove, if isRemove is true)
    """
    input: JiraSearchQueryInput!
  ): PersistJiraSearchQueryPayload!

  """
  Request to be invited to a team in real time
  """
  pushInvitation(
    """
    the meeting ID the pusher would like to join
    """
    meetingId: ID
    teamId: ID!
  ): PushInvitationPayload

  """
  Change a facilitator while the meeting is in progress
  """
  promoteNewMeetingFacilitator(
    """
    userId of the new facilitator for this meeting
    """
    facilitatorUserId: ID!
    meetingId: ID!
  ): PromoteNewMeetingFacilitatorPayload

  """
  Promote another team member to be the leader
  """
  promoteToTeamLead(
    """
    Team id of the team which is about to get a new team leader
    """
    teamId: ID!

    """
    userId who will be set as a new team leader
    """
    userId: ID!
  ): PromoteToTeamLeadPayload

  """
  Update the description of a reflection prompt
  """
  reflectTemplatePromptUpdateDescription(
    promptId: ID!
    description: String!
  ): ReflectTemplatePromptUpdateDescriptionPayload

  """
  Update the description of a poker template dimension
  """
  pokerTemplateDimensionUpdateDescription(
    dimensionId: ID!
    description: String!
  ): PokerTemplateDimensionUpdateDescriptionPayload
  reflectTemplatePromptUpdateGroupColor(
    promptId: ID!
    groupColor: String!
  ): ReflectTemplatePromptUpdateGroupColorPayload

  """
  Remove an agenda item
  """
  removeAgendaItem(
    """
    The agenda item unique id
    """
    agendaItemId: ID!
  ): RemoveAgendaItemPayload

  """
  Disconnect a team member from atlassian
  """
  removeAtlassianAuth(
    """
    the teamId to disconnect from the token
    """
    teamId: ID!
  ): RemoveAtlassianAuthPayload!

  """
  Disconnect a team member from GitHub
  """
  removeGitHubAuth(
    """
    the teamId to disconnect from the token
    """
    teamId: ID!
  ): RemoveGitHubAuthPayload!

  """
  Remove a user from an org
  """
  removeOrgUser(
    """
    the user to remove
    """
    userId: ID!

    """
    the org that does not want them anymore
    """
    orgId: ID!
  ): RemoveOrgUserPayload

  """
  Remove a poker meeting template
  """
  removePokerTemplate(templateId: ID!): RemovePokerTemplatePayload!

  """
  Remove a template full of prompts
  """
  removeReflectTemplate(templateId: ID!): RemoveReflectTemplatePayload

  """
  Remove a prompt from a template
  """
  removeReflectTemplatePrompt(promptId: ID!): RemoveReflectTemplatePromptPayload

  """
  Remove a dimension from a template
  """
  removePokerTemplateDimension(dimensionId: ID!): RemovePokerTemplateDimensionPayload!

  """
  Rename a meeting
  """
  renameMeeting(
    """
    the new meeting name
    """
    name: String!

    """
    the meeting with the new name
    """
    meetingId: ID!
  ): RenameMeetingPayload!

  """
  Rename a meeting template
  """
  renameMeetingTemplate(templateId: ID!, name: String!): RenameMeetingTemplatePayload

  """
  Rename a reflect template prompt
  """
  renameReflectTemplatePrompt(promptId: ID!, question: String!): RenameReflectTemplatePromptPayload

  """
  Rename a poker template dimension
  """
  renamePokerTemplateDimension(
    dimensionId: ID!
    name: String!
  ): RenamePokerTemplateDimensionPayload!

  """
  Rename a poker template scale
  """
  renamePokerTemplateScale(scaleId: ID!, name: String!): RenamePokerTemplateScalePayload!

  """
  Remove a scale from a template
  """
  removePokerTemplateScale(scaleId: ID!): RemovePokerTemplateScalePayload!

  """
  Remove a scale value from the scale of a template
  """
  removePokerTemplateScaleValue(scaleId: ID!, label: String!): RemovePokerTemplateScaleValuePayload!

  """
  Remove a reflection
  """
  removeReflection(reflectionId: ID!): RemoveReflectionPayload

  """
  Disconnect a team member from Slack
  """
  removeSlackAuth(
    """
    the teamId to disconnect from the token
    """
    teamId: ID!
  ): RemoveSlackAuthPayload!

  """
  Remove a team member from the team
  """
  removeTeamMember(
    """
    The teamMemberId of the person who is being removed
    """
    teamMemberId: ID!
  ): RemoveTeamMemberPayload

  """
  Reset the password for an account
  """
  resetPassword(
    """
    the password reset token
    """
    token: ID!

    """
    The new password for the account
    """
    newPassword: String!
  ): ResetPasswordPayload!

  """
  Reset a retro meeting to group stage
  """
  resetRetroMeetingToGroupStage(meetingId: ID!): ResetRetroMeetingToGroupStagePayload!

  """
  track an event in segment, like when errors are hit
  """
  segmentEventTrack(event: String!, options: SegmentEventTrackOptions): Boolean

  """
  Set the selected template for the upcoming retro meeting
  """
  selectTemplate(selectedTemplateId: ID!, teamId: ID!): SelectTemplatePayload

  """
  Share where in the app the viewer is
  """
  setAppLocation(
    """
    The location the viewer is currently at
    """
    location: String
  ): SetAppLocationPayload!

  """
  Enabled or disable the icebreaker round
  """
  setMeetingSettings(
    settingsId: ID!

    """
    true to turn icebreaker phase on, false to turn it off
    """
    checkinEnabled: Boolean

    """
    disables anonymity of reflections
    """
    disableAnonymity: Boolean
  ): SetMeetingSettingsPayload!

  """
  Update the default Slack channel where notifications are sent
  """
  setDefaultSlackChannel(slackChannelId: ID!, teamId: ID!): SetDefaultSlackChannelPayload!

  """
  Set the role of a user
  """
  setOrgUserRole(
    """
    The org to affect
    """
    orgId: ID!

    """
    the user who is receiving a role change
    """
    userId: ID!

    """
    the user’s new role
    """
    role: String
  ): SetOrgUserRolePayload

  """
  Focus (or unfocus) a phase item
  """
  setPhaseFocus(
    meetingId: ID!

    """
    The currently focused phase item
    """
    focusedPromptId: ID
  ): SetPhaseFocusPayload

  """
  Set or clear a timer for a meeting stage
  """
  setStageTimer(
    """
    the id of the meeting
    """
    meetingId: ID!

    """
    The time the timer is scheduled to go off (based on client clock), null if unsetting the timer
    """
    scheduledEndTime: DateTime

    """
    scheduledEndTime - now. Used to reconcile bad client clocks. Present for time limit, else null
    """
    timeRemaining: Float
  ): SetStageTimerPayload!
  setSlackNotification(
    slackChannelId: ID
    slackNotificationEvents: [SlackNotificationEventEnum!]!
    teamId: ID!
  ): SetSlackNotificationPayload!

  """
  Sign up using an email address and password
  """
  signUpWithPassword(
    email: ID!
    password: String!

    """
    optional segment id created before they were a user
    """
    segmentId: ID

    """
    used to determine what suggested actions to create
    """
    invitationToken: ID
  ): UserLogInPayload!

  """
  Broadcast that the viewer started dragging a reflection
  """
  startDraggingReflection(
    reflectionId: ID!
    dragId: ID!
    isSpotlight: Boolean
  ): StartDraggingReflectionPayload

  """
  Start a new meeting
  """
  startCheckIn(
    """
    The team starting the meeting
    """
    teamId: ID!
  ): StartCheckInPayload!

  """
  Start a new meeting
  """
  startRetrospective(
    """
    The team starting the meeting
    """
    teamId: ID!
  ): StartRetrospectivePayload!

  """
  Start a new sprint poker meeting
  """
  startSprintPoker(
    """
    The team starting the meeting
    """
    teamId: ID!
  ): StartSprintPokerPayload!

  """
  Broadcast that the viewer highlights a task
  """
  setTaskHighlight(taskId: ID!, meetingId: ID!, isHighlighted: Boolean!): SetTaskHighlightPayload!

  """
  Update an agenda item
  """
  updateAgendaItem(
    """
    The updated item including an id, content, status, sortOrder
    """
    updatedAgendaItem: UpdateAgendaItemInput!
  ): UpdateAgendaItemPayload

  """
  Update the content of a comment
  """
  updateCommentContent(
    commentId: ID!

    """
    A stringified draft-js document containing thoughts
    """
    content: String!
    meetingId: ID!
  ): UpdateCommentContentPayload

  """
  Update an existing credit card on file
  """
  updateCreditCard(
    """
    the org requesting the changed billing
    """
    orgId: ID!

    """
    The token that came back from stripe
    """
    stripeToken: ID!
  ): UpdateCreditCardPayload

  """
  Update an with a change in name, avatar
  """
  updateOrg(
    """
    the updated org including the id, and at least one other field
    """
    updatedOrg: UpdateOrgInput!
  ): UpdateOrgPayload!

  """
  Update the scale used for a dimension in a template
  """
  updatePokerTemplateDimensionScale(
    dimensionId: ID!
    scaleId: ID!
  ): UpdatePokerTemplateDimensionScalePayload!

  """
  Update the label, numerical value or color of a scale value in a scale
  """
  updatePokerTemplateScaleValue(
    scaleId: ID!
    oldScaleValue: TemplateScaleInput!
    newScaleValue: TemplateScaleInput!
  ): UpdatePokerTemplateScaleValuePayload!

  """
  Update a Team's Icebreaker in a new meeting
  """
  updateNewCheckInQuestion(
    """
    ID of the Team which will have its Icebreaker updated
    """
    meetingId: ID!

    """
    The Team's new Icebreaker
    """
    checkInQuestion: String!
  ): UpdateNewCheckInQuestionPayload

  """
  all the info required to provide an accurate display-specific location of where an item is
  """
  updateDragLocation(input: UpdateDragLocationInput!): Boolean

  """
  Add or remove a task and its estimate phase from the meeting
  """
  updatePokerScope(
    """
    the meeting with the estimate phases to modify
    """
    meetingId: ID!

    """
    The list of items to add/remove to the estimate phase
    """
    updates: [UpdatePokerScopeItemInput!]!
  ): UpdatePokerScopePayload!

  """
  Update the content of a reflection
  """
  updateReflectionContent(
    reflectionId: ID!

    """
    A stringified draft-js document containing thoughts
    """
    content: String!
  ): UpdateReflectionContentPayload

  """
  Update the title of a reflection group
  """
  updateReflectionGroupTitle(
    reflectionGroupId: ID!

    """
    The new title for the group
    """
    title: String!
  ): UpdateReflectionGroupTitlePayload

  """
  Change the max votes for participants
  """
  updateRetroMaxVotes(
    """
    The total number of votes for each participant
    """
    totalVotes: Int!

    """
    The total number of votes for each participant to vote on a single topic
    """
    maxVotesPerGroup: Int!

    """
    the meeting to update
    """
    meetingId: ID!
  ): UpdateRetroMaxVotesPayload!

  """
  Update a task with a change in content, ownership, or status
  """
  updateTask(
    """
    The part of the site where the creation occurred
    """
    area: AreaEnum

    """
    the updated task including the id, and at least one other field
    """
    updatedTask: UpdateTaskInput!
  ): UpdateTaskPayload

  """
  Set or unset the due date of a task
  """
  updateTaskDueDate(
    """
    The task id
    """
    taskId: ID!

    """
    the new due date. if not a valid date, it will unset the due date
    """
    dueDate: DateTime
  ): UpdateTaskDueDatePayload
  updateTeamName(
    """
    The input object containing the teamId and any modified fields
    """
    updatedTeam: UpdatedTeamInput!
  ): UpdateTeamNamePayload

  """
  Change the scope of a template
  """
  updateTemplateScope(
    """
    The id of the template
    """
    templateId: ID!

    """
    the new scope
    """
    scope: SharingScopeEnum!
  ): UpdateTemplateScopePayload!
  updateUserProfile(
    """
    The input object containing the user profile fields that can be changed
    """
    updatedUser: UpdateUserProfileInput!
  ): UpdateUserProfilePayload

  """
  Upgrade an account to the paid service
  """
  upgradeToTeamTier(
    """
    the org requesting the upgrade
    """
    orgId: ID!

    """
    The token that came back from stripe
    """
    stripeToken: ID!
  ): UpgradeToTeamTierPayload

  """
  Upload an image for an org avatar
  """
  uploadOrgImage(
    """
    the org avatar image file
    """
    file: File!

    """
    The org id to upload an avatar for
    """
    orgId: ID!
  ): UpdateOrgPayload!

  """
  Upload an image for a user avatar
  """
  uploadUserImage(
    """
    the user avatar image file
    """
    file: File!
  ): UpdateUserProfilePayload

  """
  Verify an email address and sign in if not already a user
  """
  verifyEmail(
    """
    The 48-byte url-safe base64 encoded verification token
    """
    verificationToken: ID!
  ): UserLogInPayload!

  """
  Cast your vote for a reflection group
  """
  voteForReflectionGroup(
    """
    true if the user wants to remove one of their votes
    """
    isUnvote: Boolean
    reflectionGroupId: ID!
  ): VoteForReflectionGroupPayload

  """
  Cast a vote for the estimated points for a given dimension
  """
  voteForPokerStory(
    meetingId: ID!

    """
    The stage that contains the dimension to vote for
    """
    stageId: ID!

    """
    The label of the scaleValue to vote for. If null, remove the vote
    """
    score: String
  ): VoteForPokerStoryPayload!

  """
  Progresses the stage dimension to the reveal & discuss step
  """
  pokerRevealVotes(meetingId: ID!, stageId: ID!): PokerRevealVotesPayload!

  """
  Remove all votes, the final vote, and reset the stage
  """
  pokerResetDimension(meetingId: ID!, stageId: ID!): PokerResetDimensionPayload!

  """

  """
  pokerAnnounceDeckHover(
    meetingId: ID!
    stageId: ID!

    """
    true if the viewer has started hovering the deck, else false
    """
    isHover: Boolean!
  ): PokerAnnounceDeckHoverPayload!

  """
  Move a scale value to an index
  """
  movePokerTemplateScaleValue(
    scaleId: ID!

    """
    The label of the moving scale value
    """
    label: String!

    """
    The index position where the scale value is moving to
    """
    index: Int!
  ): MovePokerTemplateScaleValuePayload!

  """
  Create a meeting member for a user
  """
  joinMeeting(meetingId: ID!): JoinMeetingPayload!

  """
  Set whether the user is spectating poker meeting
  """
  setPokerSpectate(
    meetingId: ID!

    """
    true if the viewer is spectating poker and does not want to vote. else false
    """
    isSpectating: Boolean!
  ): SetPokerSpectatePayload!

  """

  """
  persistGitHubSearchQuery(
    """
    the team witht the settings we add the query to
    """
    teamId: ID!

    """
    The query string as sent to GitHub
    """
    queryString: String!

    """
    true if this query should be deleted
    """
    isRemove: Boolean
  ): PersistGitHubSearchQueryPayload!

  """
  Update a task estimate
  """
  setTaskEstimate(taskEstimate: TaskEstimateInput!): SetTaskEstimatePayload!

  """
  Show/hide the drawer in the team dashboard
  """
  toggleTeamDrawer(
    """
    the team to show/hide the drawer for
    """
    teamId: ID!

    """
    The type of team drawer that the viewer is toggling. Null if closing the drawer.
    """
    teamDrawerType: TeamDrawer
  ): ToggleTeamDrawerPayload!

  """
  Update how a parabol dimension maps to a GitHub label
  """
  updateGitHubDimensionField(
    dimensionName: String!

    """
    The template string to map to a label
    """
    labelTemplate: String!

    """
    The repo the issue lives on
    """
    nameWithOwner: ID!

    """
    The meeting the update happend in. Returns a meeting object with updated serviceField
    """
    meetingId: ID!
  ): UpdateGitHubDimensionFieldPayload!
  createPoll(
    """
    The new poll including title and poll options
    """
    newPoll: CreatePollInput!
  ): CreatePollPayload!

  """
  Add an integration authorization for a specific team member
  """
  addTeamMemberIntegrationAuth(
    providerId: ID!
    teamId: ID!

    """
    The OAuth2 code or personal access token. Null for webhook auth
    """
    oauthCodeOrPat: ID

    """
    OAuth1 token verifier
    """
    oauthVerifier: ID

    """
    The URL the OAuth2 token will be sent to. Null for webhook auth
    """
    redirectUri: URL
  ): AddTeamMemberIntegrationAuthPayload!

  """
  Adds a new Integration Provider configuration
  """
  addIntegrationProvider(
    """
    The new Integration Provider
    """
    input: AddIntegrationProviderInput!
  ): AddIntegrationProviderPayload!

  """
  Update the Integration Provider settings
  """
  updateIntegrationProvider(
    """
    The new Integration Provider
    """
    provider: UpdateIntegrationProviderInput!
  ): UpdateIntegrationProviderPayload!

  """
  Remove an Integration Provider, and any associated tokens
  """
  removeIntegrationProvider(
    """
    Id of the Integration Provider to remove
    """
    providerId: ID!
  ): RemoveIntegrationProviderPayload!

  """
  Remove the integrated auth for a given team member
  """
  removeTeamMemberIntegrationAuth(
    """
    The Integration Provider service name related to the token
    """
    service: IntegrationProviderServiceEnum!

    """
    The team id related to the token
    """
    teamId: ID!
  ): RemoveTeamMemberIntegrationAuthPayload!
}

type AddAgendaItemPayload {
  error: StandardMutationError
  agendaItem: AgendaItem
  meetingId: ID

  """
  The meeting with the updated agenda item, if any
  """
  meeting: NewMeeting
}

input CreateAgendaItemInput {
  """
  The content of the agenda item
  """
  content: String!

  """
  True if the agenda item has been pinned
  """
  pinned: Boolean!
  teamId: ID!

  """
  The team member ID of the person creating the agenda item
  """
  teamMemberId: ID!

  """
  The sort order of the agenda item in the list
  """
  sortOrder: Float

  """
  The meeting ID of the agenda item
  """
  meetingId: String
}

type AddAtlassianAuthPayload {
  error: StandardMutationError

  """
  The newly created auth
  """
  atlassianIntegration: AtlassianIntegration
  teamId: ID

  """
  The team member with the updated atlassianAuth
  """
  teamMember: TeamMember

  """
  The user with updated atlassianAuth
  """
  user: User
}

"""
Return object for AddCommentPayload
"""
union AddCommentPayload = ErrorPayload | AddCommentSuccess

type ErrorPayload {
  error: StandardMutationError!
}

type AddCommentSuccess {
  """
  the comment just created
  """
  comment: Comment!

  """
  The id of the meeting where the comment was added
  """
  meetingId: ID!
}

input AddCommentInput {
  """
  A stringified draft-js document containing thoughts
  """
  content: String!

  """
  true if the comment should be anonymous
  """
  isAnonymous: Boolean

  """
  foreign key for the discussion this was created in
  """
  discussionId: ID!
  threadSortOrder: Float!
  threadParentId: ID
}

type AddPokerTemplatePayload {
  error: StandardMutationError
  pokerTemplate: PokerTemplate
}

type AddPokerTemplateDimensionPayload {
  error: StandardMutationError
  dimension: TemplateDimension
}

type AddPokerTemplateScalePayload {
  error: StandardMutationError
  scale: TemplateScale
}

type AddPokerTemplateScaleValuePayload {
  error: StandardMutationError
  scale: TemplateScale
}

"""
Input for adding a new scale
"""
input AddTemplateScaleInput {
  """
  The color used to visually group a scale value
  """
  color: String!

  """
  The label for this value, e.g., XS, M, L
  """
  label: String!
}

"""
Return object for AddReactjiToReactablePayload
"""
union AddReactjiToReactablePayload = ErrorPayload | AddReactjiToReactableSuccess

type AddReactjiToReactableSuccess {
  """
  the Reactable with the updated list of reactjis
  """
  reactable: Reactable!
}

"""
The type of reactable
"""
enum ReactableEnum {
  COMMENT
  REFLECTION
  RESPONSE
}

type AddReflectTemplatePayload {
  error: StandardMutationError
  reflectTemplate: ReflectTemplate
}

type AddReflectTemplatePromptPayload {
  error: StandardMutationError
  prompt: ReflectPrompt
}

type AddSlackAuthPayload {
  error: StandardMutationError

  """
  The newly created auth
  """
  slackIntegration: SlackIntegration

  """
  The user with updated slackAuth
  """
  user: User
}

type AddGitHubAuthPayload {
  error: StandardMutationError

  """
  The newly created auth
  """
  githubIntegration: GitHubIntegration

  """
  The team member with the updated auth
  """
  teamMember: TeamMember

  """
  The user with updated githubAuth
  """
  user: User
}

type AddOrgPayload {
  organization: Organization
  error: StandardMutationError

  """
  The new auth token sent to the mutator
  """
  authToken: ID
  team: Team

  """
  The teamMember that just created the new team, if this is a creation
  """
  teamMember: TeamMember

  """
  The ID of the suggestion to create a new team
  """
  removedSuggestedActionId: ID
}

input NewTeamInput {
  """
  The name of the team
  """
  name: String!

  """
  The unique orginization ID that pays for the team
  """
  orgId: ID
}

type AddTeamPayload {
  error: StandardMutationError

  """
  The new auth token sent to the mutator
  """
  authToken: ID
  team: Team

  """
  The teamMember that just created the new team, if this is a creation
  """
  teamMember: TeamMember

  """
  The ID of the suggestion to create a new team
  """
  removedSuggestedActionId: ID
}

type ArchiveOrganizationPayload {
  error: StandardMutationError
  orgId: ID
  teams: [Team!]

  """
  all the suggested actions that never happened
  """
  removedSuggestedActionIds: [ID]
}

type ArchiveTeamPayload {
  error: StandardMutationError
  team: Team

  """
  A notification explaining that the team was archived and removed from view
  """
  notification: NotifyTeamArchived

  """
  all the suggested actions that never happened
  """
  removedSuggestedActionIds: [ID]

  """
  A list of the ids of templates created by a team
  """
  teamTemplateIds: [ID!]!
}

"""
A notification alerting the user that a team they were on is now archived
"""
type NotifyTeamArchived implements Notification {
  """
  the user that archived the team
  """
  archivor: User!
  team: Team!

  """
  A shortid for the notification
  """
  id: ID!

  """
  UNREAD if new, READ if viewer has seen it, CLICKED if viewed clicked it
  """
  status: NotificationStatusEnum!

  """
  The datetime to activate the notification & send it to the client
  """
  createdAt: DateTime!
  type: NotificationEnum!

  """
  *The userId that should see this notification
  """
  userId: ID!
}

"""
Return object for ArchiveTimelineEventPayload
"""
union ArchiveTimelineEventPayload = ErrorPayload | ArchiveTimelineEventSuccess

type ArchiveTimelineEventSuccess {
  """
  the archived timelineEvent
  """
  timelineEvent: TimelineEvent!
}

type AutoGroupReflectionsPayload {
  error: StandardMutationError
  meeting: RetrospectiveMeeting
  reflections: [RetroReflection]
  reflectionGroups: [RetroReflectionGroup]
  removedReflectionGroups: [RetroReflectionGroup]
}

type ChangeTaskTeamPayload {
  error: StandardMutationError
  task: Task

  """
  the taskId sent to a user who is not on the new team so they can remove it from their client
  """
  removedTaskId: ID
}

type SetNotificationStatusPayload {
  error: StandardMutationError

  """
  The updated notification
  """
  notification: Notification
}

type CreateTaskIntegrationPayload {
  error: StandardMutationError
  task: Task
}

"""
Return object for CreateMassInvitationPayload
"""
union CreateMassInvitationPayload = ErrorPayload | CreateMassInvitationSuccess

type CreateMassInvitationSuccess {
  """
  the team with the updated mass inivtation
  """
  team: Team!
}

"""
Authorization URL constructed after creating a new request token
"""
type CreateOAuth1AuthorizationURLPayload {
  error: StandardMutationError

  """
  Authorization URL including oauth_token to start authorization flow
  """
  url: String
}

type CreateReflectionPayload {
  error: StandardMutationError
  meeting: NewMeeting
  reflectionId: ID
  reflection: RetroReflection

  """
  The group automatically created for the reflection
  """
  reflectionGroup: RetroReflectionGroup

  """
  The stages that were unlocked by navigating
  """
  unlockedStages: [NewMeetingStage!]
}

input CreateReflectionInput {
  """
  A stringified draft-js document containing thoughts
  """
  content: String
  meetingId: ID!

  """
  The prompt the reflection belongs to
  """
  promptId: ID!
  sortOrder: Float!
}

type CreateTaskPayload {
  error: StandardMutationError
  task: Task
  involvementNotification: NotifyTaskInvolves
}

"""
A notification sent to someone who was just added to a team
"""
type NotifyTaskInvolves implements Notification & TeamNotification {
  """
  A shortid for the notification
  """
  id: ID!

  """
  UNREAD if new, READ if viewer has seen it, CLICKED if viewed clicked it
  """
  status: NotificationStatusEnum!

  """
  The datetime to activate the notification & send it to the client
  """
  createdAt: DateTime!
  type: NotificationEnum!

  """
  *The userId that should see this notification
  """
  userId: ID!

  """
  How the user is affiliated with the task
  """
  involvement: TaskInvolvementType!

  """
  The taskId that now involves the userId
  """
  taskId: ID!

  """
  The task that now involves the userId
  """
  task: Task

  """
  The teamMemberId of the person that made the change
  """
  changeAuthorId: ID

  """
  The TeamMember of the person that made the change
  """
  changeAuthor: TeamMember!
  teamId: ID!

  """
  The team the task is on
  """
  team: Team!
}

"""
How a user is involved with a task (listed in hierarchical order)
"""
enum TaskInvolvementType {
  ASSIGNEE
  MENTIONEE
}

input CreateTaskInput {
  content: String
  plaintextContent: String

  """
  foreign key for the meeting this was created in
  """
  meetingId: ID

  """
  foreign key for the thread this was created in
  """
  discussionId: ID
  threadSortOrder: Float
  threadParentId: ID
  sortOrder: Float
  status: TaskStatusEnum!

  """
  teamId, the team the task is on
  """
  teamId: ID!

  """
  userId, the owner of the task. This can be null if the task is not assigned to anyone.
  """
  userId: ID
  integration: CreateTaskIntegrationInput
}

input CreateTaskIntegrationInput {
  """
  The service to push this new task to
  """
  service: TaskServiceEnum!

  """
  The key or composite key where the task should live in the service, e.g. nameWithOwner or cloudId:projectKey
  """
  serviceProjectHash: String!
}

"""
The list of services for task integrations
"""
enum TaskServiceEnum {
  github
  jira
  PARABOL
}

"""
The part of the site that is calling the mutation
"""
enum AreaEnum {
  meeting
  teamDash
  userDash
}

"""
Return object for DeleteCommentPayload
"""
union DeleteCommentPayload = ErrorPayload | DeleteCommentSuccess

type DeleteCommentSuccess {
  commentId: ID!

  """
  the comment just deleted
  """
  comment: Comment!
}

type DeleteTaskPayload {
  error: StandardMutationError

  """
  The task that was deleted
  """
  task: Task
}

type DeleteUserPayload {
  error: StandardMutationError
}

type DenyPushInvitationPayload {
  error: StandardMutationError
  teamId: ID
  userId: ID
}

type DismissNewFeaturePayload {
  error: StandardMutationError
}

type DismissSuggestedActionPayload {
  error: StandardMutationError

  """
  The user that dismissed the action
  """
  user: User

  """
  The id of the removed suggested action
  """
  removedSuggestedActionId: ID
}

type DowngradeToStarterPayload {
  error: StandardMutationError

  """
  The new Starter Org
  """
  organization: Organization

  """
  The updated teams under the org
  """
  teams: [Team]
}

type DragDiscussionTopicPayload {
  error: StandardMutationError
  meeting: NewMeeting
  stage: RetroDiscussStage
}

"""
Return object for DragEstimatingTaskPayload
"""
union DragEstimatingTaskPayload = ErrorPayload | DragEstimatingTaskSuccess

type DragEstimatingTaskSuccess {
  meetingId: ID!
  meeting: PokerMeeting!
  stageIds: [ID!]!
  stages: [EstimateStage!]!
}

"""
Return object for EmailPasswordResetPayload
"""
union EmailPasswordResetPayload = ErrorPayload | EmailPasswordResetSuccess

type EmailPasswordResetSuccess {
  """
  True if the email password reset was successfully sent
  """
  success: Boolean
}

"""
Return object for EditCommentingPayload
"""
union EditCommentingPayload = ErrorPayload | EditCommentingSuccess

type EditCommentingSuccess {
  """
  The discussion the comment was created in
  """
  discussionId: ID!

  """
  The discussion where the commenting state changed
  """
  discussion: Discussion!
}

"""
Return object for EndSprintPokerPayload
"""
union EndSprintPokerPayload = ErrorPayload | EndSprintPokerSuccess

type EndSprintPokerSuccess {
  """
  true if the meeting was killed (ended before reaching last stage)
  """
  isKill: Boolean!
  meetingId: ID!
  meeting: PokerMeeting!
  removedTaskIds: [ID!]!
  team: Team!
  teamId: ID!
}

type EditReflectionPayload {
  error: StandardMutationError
  promptId: ID

  """
  The socketId of the client editing the card (uses socketId to maintain anonymity)
  """
  editorId: ID

  """
  true if the reflection is being edited, else false
  """
  isEditing: Boolean
}

type EditTaskPayload {
  error: StandardMutationError
  task: Task
  editor: User

  """
  true if the editor is editing, false if they stopped editing
  """
  isEditing: Boolean
}

"""
Return object for EndCheckInPayload
"""
union EndCheckInPayload = ErrorPayload | EndCheckInSuccess

type EndCheckInSuccess {
  """
  true if the meeting was killed (ended before reaching last stage)
  """
  isKill: Boolean!
  team: Team!
  meeting: ActionMeeting!

  """
  The ID of the suggestion to try a check-in meeting, if tried
  """
  removedSuggestedActionId: ID
  removedTaskIds: [ID!]

  """
  An event that is important to the viewer, e.g. an ended meeting
  """
  timelineEvent: TimelineEvent!
  updatedTaskIds: [ID!]

  """
  Any tasks that were updated during the meeting
  """
  updatedTasks: [Task!]
}

type EndDraggingReflectionPayload {
  error: StandardMutationError
  dragId: ID

  """
  The drag as sent from the team member
  """
  remoteDrag: RemoteReflectionDrag

  """
  the type of item the reflection was dropped on
  """
  dropTargetType: DragReflectionDropTargetTypeEnum

  """
  The ID that the dragged item was dropped on, if dropTargetType is not specific enough
  """
  dropTargetId: ID
  meeting: RetrospectiveMeeting
  meetingId: ID
  reflection: RetroReflection
  reflectionGroupId: ID
  reflectionId: ID

  """
  foreign key to get user
  """
  userId: ID

  """
  The group encapsulating the new reflection. A new one was created if one was not provided.
  """
  reflectionGroup: RetroReflectionGroup

  """
  The old group the reflection was in
  """
  oldReflectionGroup: RetroReflectionGroup
}

"""
Info associated with a current drag
"""
type RemoteReflectionDrag {
  id: ID!

  """
  The userId of the person currently dragging the reflection
  """
  dragUserId: ID

  """
  The name of the dragUser
  """
  dragUserName: String
  isSpotlight: Boolean
  clientHeight: Float
  clientWidth: Float

  """
  The primary key of the item being drug
  """
  sourceId: ID!

  """
  The estimated destination of the item being drug
  """
  targetId: ID

  """
  horizontal distance from the top left of the target
  """
  targetOffsetX: Float

  """
  vertical distance from the top left of the target
  """
  targetOffsetY: Float

  """
  the left of the source, relative to the client window
  """
  clientX: Float

  """
  the top of the source, relative to the client window
  """
  clientY: Float
}

"""
The possible places a reflection can be dropped
"""
enum DragReflectionDropTargetTypeEnum {
  REFLECTION_GROUP
  REFLECTION_GRID
}

"""
Return object for EndRetrospectivePayload
"""
union EndRetrospectivePayload = ErrorPayload | EndRetrospectiveSuccess

type EndRetrospectiveSuccess {
  """
  true if the meeting was killed (ended before reaching last stage)
  """
  isKill: Boolean!
  team: Team!
  meeting: RetrospectiveMeeting!

  """
  The ID of the suggestion to try a retro meeting, if tried
  """
  removedSuggestedActionId: ID
  removedTaskIds: [ID!]!

  """
  An event that is important to the viewer, e.g. an ended meeting
  """
  timelineEvent: TimelineEvent!
}

"""
Return object for FlagReadyToAdvancePayload
"""
union FlagReadyToAdvancePayload = ErrorPayload | FlagReadyToAdvanceSuccess

type FlagReadyToAdvanceSuccess {
  """
  the meeting with the updated readyCount
  """
  meeting: NewMeeting!

  """
  the stage with the updated readyCount
  """
  stage: NewMeetingStage!
}

type InactivateUserPayload {
  error: StandardMutationError

  """
  The user that has been inactivated
  """
  user: User
}

type InvalidateSessionsPayload {
  error: StandardMutationError

  """
  The new, only valid auth token
  """
  authToken: ID
}

type InviteToTeamPayload {
  error: StandardMutationError

  """
  The team the inviter is inviting the invitee to
  """
  team: Team

  """
  A list of email addresses the invitations were sent to
  """
  invitees: [Email!]

  """
  the notification ID if this payload is sent to a subscriber, else null
  """
  teamInvitationNotificationId: ID

  """
  The notification sent to the invitee if they are a parabol user
  """
  teamInvitationNotification: NotificationTeamInvitation

  """
  the `invite your team` suggested action that was removed, if any
  """
  removedSuggestedActionId: ID
}

type LoginWithPasswordPayload {
  error: StandardMutationError

  """
  The new auth token
  """
  authToken: ID
  userId: ID

  """
  the newly created user
  """
  user: User
}

type MovePokerTemplateDimensionPayload {
  error: StandardMutationError
  dimension: TemplateDimension
}

type MoveReflectTemplatePromptPayload {
  error: StandardMutationError
  prompt: ReflectPrompt
}

type NavigateMeetingPayload {
  error: StandardMutationError
  meeting: NewMeeting

  """
  The stage that the facilitator is now on
  """
  facilitatorStage: NewMeetingStage

  """
  The stage that the facilitator left
  """
  oldFacilitatorStage: NewMeetingStage

  """
  Additional details triggered by completing certain phases
  """
  phaseComplete: PhaseCompletePayload

  """
  The stages that were unlocked by navigating
  """
  unlockedStages: [NewMeetingStage!]
}

type PhaseCompletePayload {
  """
  payload provided if the retro reflect phase was completed
  """
  reflect: ReflectPhaseCompletePayload

  """
  payload provided if the retro grouping phase was completed
  """
  group: GroupPhaseCompletePayload

  """
  payload provided if the retro voting phase was completed
  """
  vote: VotePhaseCompletePayload
}

type ReflectPhaseCompletePayload {
  """
  a list of empty reflection groups to remove
  """
  emptyReflectionGroupIds: [ID!]!

  """
  The grouped reflections
  """
  reflectionGroups: [RetroReflectionGroup!]!
}

type GroupPhaseCompletePayload {
  """
  a list of empty reflection groups to remove
  """
  emptyReflectionGroupIds: [ID!]!

  """
  the current meeting
  """
  meeting: RetrospectiveMeeting!

  """
  a list of updated reflection groups
  """
  reflectionGroups: [RetroReflectionGroup]
}

type VotePhaseCompletePayload {
  """
  the current meeting
  """
  meeting: RetrospectiveMeeting
}

type NewMeetingCheckInPayload {
  error: StandardMutationError
  meetingMember: MeetingMember
  meeting: NewMeeting
}

type PayLaterPayload {
  error: StandardMutationError

  """
  the ids of the meetings that were showing conversion modals
  """
  meetingId: ID

  """
  the meetings that were showing conversion modals
  """
  meeting: NewMeeting
}

"""
Return object for PersistJiraSearchQueryPayload
"""
union PersistJiraSearchQueryPayload = ErrorPayload | PersistJiraSearchQuerySuccess

type PersistJiraSearchQuerySuccess {
  """
  The newly created auth
  """
  atlassianIntegration: AtlassianIntegration
}

input JiraSearchQueryInput {
  """
  The query string, either simple or JQL depending on the isJQL flag
  """
  queryString: String!

  """
  true if the queryString is JQL, else false
  """
  isJQL: Boolean!

  """
  The list of project keys selected as a filter. null if not set
  """
  projectKeyFilters: [ID!]

  """
  true if this query should be deleted
  """
  isRemove: Boolean
}

type PushInvitationPayload {
  error: StandardMutationError
  user: User
  meetingId: ID
  team: Team
}

type PromoteNewMeetingFacilitatorPayload {
  error: StandardMutationError

  """
  The meeting in progress
  """
  meeting: NewMeeting
  facilitatorStage: NewMeetingStage

  """
  The old meeting facilitator
  """
  oldFacilitator: User
}

type PromoteToTeamLeadPayload {
  error: StandardMutationError
  team: Team
  oldLeader: TeamMember
  newLeader: TeamMember
}

type ReflectTemplatePromptUpdateDescriptionPayload {
  error: StandardMutationError
  prompt: ReflectPrompt
}

type PokerTemplateDimensionUpdateDescriptionPayload {
  error: StandardMutationError
  dimension: TemplateDimension
}

type ReflectTemplatePromptUpdateGroupColorPayload {
  error: StandardMutationError
  prompt: ReflectPrompt
}

type RemoveAgendaItemPayload {
  error: StandardMutationError
  agendaItem: AgendaItem
  meetingId: ID

  """
  The meeting with the updated agenda item, if any
  """
  meeting: NewMeeting
}

type RemoveAtlassianAuthPayload {
  error: StandardMutationError
  teamId: ID

  """
  The team member with the updated auth
  """
  teamMember: TeamMember

  """
  The user with updated atlassianAuth
  """
  user: User
}

type RemoveGitHubAuthPayload {
  error: StandardMutationError
  teamId: ID

  """
  The team member with the updated auth
  """
  teamMember: TeamMember

  """
  The user with updated githubAuth
  """
  user: User
}

type RemoveOrgUserPayload {
  error: StandardMutationError

  """
  The organization the user was removed from
  """
  organization: Organization

  """
  The teams the user was removed from
  """
  teams: [Team!]

  """
  The teamMembers removed
  """
  teamMembers: [TeamMember!]

  """
  The tasks that were archived or reassigned
  """
  updatedTasks: [Task!]

  """
  The user removed from the organization
  """
  user: User

  """
  The notifications for each team the user was kicked out of
  """
  kickOutNotifications: [NotifyKickedOut!]

  """
  The organization member that got removed
  """
  removedOrgMember: OrganizationUser
  organizationUserId: String
}

"""
A notification sent to someone who was just kicked off a team
"""
type NotifyKickedOut implements Notification {
  """
  A shortid for the notification
  """
  id: ID!

  """
  UNREAD if new, READ if viewer has seen it, CLICKED if viewed clicked it
  """
  status: NotificationStatusEnum!

  """
  The datetime to activate the notification & send it to the client
  """
  createdAt: DateTime!
  type: NotificationEnum!

  """
  *The userId that should see this notification
  """
  userId: ID!

  """
  the user that evicted recipient
  """
  evictor: User!

  """
  The name of the team the user is joining
  """
  teamName: String!

  """
  The teamId the user was kicked out of
  """
  teamId: ID!

  """
  The team the task is on
  """
  team: Team!
}

type RemovePokerTemplatePayload {
  error: StandardMutationError
  pokerTemplate: PokerTemplate
  pokerMeetingSettings: PokerMeetingSettings
}

type RemoveReflectTemplatePayload {
  error: StandardMutationError
  reflectTemplate: ReflectTemplate
  retroMeetingSettings: RetrospectiveMeetingSettings
}

type RemoveReflectTemplatePromptPayload {
  error: StandardMutationError
  reflectTemplate: ReflectTemplate
  prompt: ReflectPrompt
}

type RemovePokerTemplateDimensionPayload {
  error: StandardMutationError
  pokerTemplate: PokerTemplate
  dimension: TemplateDimension
}

"""
Return object for RenameMeetingPayload
"""
union RenameMeetingPayload = ErrorPayload | RenameMeetingSuccess

type RenameMeetingSuccess {
  """
  the renamed meeting
  """
  meeting: NewMeeting!
}

type RenameMeetingTemplatePayload {
  error: StandardMutationError
  meetingTemplate: MeetingTemplate
}

type RenameReflectTemplatePromptPayload {
  error: StandardMutationError
  prompt: ReflectPrompt
}

type RenamePokerTemplateDimensionPayload {
  error: StandardMutationError
  dimension: TemplateDimension
}

type RenamePokerTemplateScalePayload {
  error: StandardMutationError
  scale: TemplateScale
}

type RemovePokerTemplateScalePayload {
  error: StandardMutationError
  scale: TemplateScale

  """
  A list of dimensions that were using the archived scale
  """
  dimensions: [TemplateDimension!]!
}

type RemovePokerTemplateScaleValuePayload {
  error: StandardMutationError
  scale: TemplateScale
}

type RemoveReflectionPayload {
  error: StandardMutationError
  meeting: NewMeeting
  reflection: RetroReflection

  """
  The stages that were unlocked by navigating
  """
  unlockedStages: [NewMeetingStage!]
}

type RemoveSlackAuthPayload {
  error: StandardMutationError

  """
  The ID of the authorization removed
  """
  authId: ID
  teamId: ID

  """
  The user with updated slackAuth
  """
  user: User
}

type RemoveTeamMemberPayload {
  error: StandardMutationError

  """
  The team member removed
  """
  teamMember: TeamMember

  """
  The team the team member was removed from
  """
  team: Team

  """
  The tasks that got reassigned
  """
  updatedTasks: [Task!]

  """
  The user removed from the team
  """
  user: User

  """
  A notification if you were kicked out by the team leader
  """
  kickOutNotification: NotifyKickedOut
}

type ResetPasswordPayload {
  error: StandardMutationError

  """
  The new auth token
  """
  authToken: ID
  userId: ID

  """
  the user that changed their password
  """
  user: User
}

type ResetRetroMeetingToGroupStagePayload {
  error: StandardMutationError
  meeting: NewMeeting
}

input SegmentEventTrackOptions {
  teamId: ID
  orgId: ID
  phase: NewMeetingPhaseTypeEnum
  eventId: Int
  actionType: String
  spotlightSearchQuery: String
  meetingId: ID
  reflectionId: ID
  viewerId: ID
  reflectionsCount: Int
}

type SelectTemplatePayload {
  error: StandardMutationError
  meetingSettings: TeamMeetingSettings
}

"""
Return object for SetAppLocationPayload
"""
union SetAppLocationPayload = ErrorPayload | SetAppLocationSuccess

type SetAppLocationSuccess {
  """
  the user with the updated location
  """
  user: User!
}

type SetMeetingSettingsPayload {
  error: StandardMutationError
  settings: TeamMeetingSettings
}

"""
Return object for SetDefaultSlackChannelPayload
"""
union SetDefaultSlackChannelPayload = ErrorPayload | SetDefaultSlackChannelSuccess

type SetDefaultSlackChannelSuccess {
  """
  The id of the slack channel that is now the default slack channel
  """
  slackChannelId: ID!

  """
  The team member with the updated slack channel
  """
  teamMember: TeamMember!
}

interface SetOrgUserRolePayload {
  error: StandardMutationError
  organization: Organization
  updatedOrgMember: OrganizationUser
}

type SetPhaseFocusPayload {
  error: StandardMutationError
  meeting: RetrospectiveMeeting!
  reflectPhase: ReflectPhase!
}

type SetStageTimerPayload {
  error: StandardMutationError

  """
  The updated stage
  """
  stage: NewMeetingStage
}

type SetSlackNotificationPayload {
  error: StandardMutationError
  slackNotifications: [SlackNotification!]

  """
  The user with updated slack notifications
  """
  user: User
}

type StartDraggingReflectionPayload {
  error: StandardMutationError

  """
  The proposed start/end of a drag. Subject to race conditions, it is up to the client to decide to accept or ignore
  """
  remoteDrag: RemoteReflectionDrag
  meeting: NewMeeting
  meetingId: ID
  reflection: RetroReflection
  reflectionId: ID
  teamId: ID
}

"""
Return object for StartCheckInPayload
"""
union StartCheckInPayload = ErrorPayload | StartCheckInSuccess

type StartCheckInSuccess {
  meeting: ActionMeeting!
  meetingId: ID!
  team: Team!
}

"""
Return object for StartRetrospectivePayload
"""
union StartRetrospectivePayload = ErrorPayload | StartRetrospectiveSuccess

type StartRetrospectiveSuccess {
  meeting: RetrospectiveMeeting!
  meetingId: ID!
  team: Team!
}

"""
Return object for StartSprintPokerPayload
"""
union StartSprintPokerPayload = ErrorPayload | StartSprintPokerSuccess

type StartSprintPokerSuccess {
  meetingId: ID!
  meeting: PokerMeeting!
  team: Team!
  teamId: ID!
}

"""
Return object for SetTaskHighlightPayload
"""
union SetTaskHighlightPayload = ErrorPayload | SetTaskHighlightSuccess

type SetTaskHighlightSuccess {
  """
  Meeting where the task is highlighted
  """
  meetingId: ID!

  """
  Task which highlight changed
  """
  taskId: ID!

  """
  Task which highlight changed
  """
  task: Task!
}

type UpdateAgendaItemPayload {
  agendaItem: AgendaItem
  meetingId: ID

  """
  The meeting with the updated agenda item, if any
  """
  meeting: NewMeeting
  error: StandardMutationError
}

input UpdateAgendaItemInput {
  """
  The unique agenda item ID, composed of a teamId::shortid
  """
  id: ID!

  """
  The content of the agenda item
  """
  content: String

  """
  True if agenda item has been pinned
  """
  pinned: Boolean

  """
  True if not processed or deleted
  """
  isActive: Boolean

  """
  The sort order of the agenda item in the list
  """
  sortOrder: Float
}

"""
Return object for UpdateCommentContentPayload
"""
union UpdateCommentContentPayload = ErrorPayload | UpdateCommentContentSuccess

type UpdateCommentContentSuccess {
  """
  the comment with updated content
  """
  comment: Comment!
}

type UpdateCreditCardPayload {
  error: StandardMutationError

  """
  The organization that received the updated credit card
  """
  organization: Organization

  """
  The teams that are now paid up
  """
  teamsUpdated: [Team]
}

type UpdateOrgPayload {
  error: StandardMutationError

  """
  The updated org
  """
  organization: Organization
}

input UpdateOrgInput {
  """
  The unique action ID
  """
  id: ID!

  """
  The name of the org
  """
  name: String

  """
  The org avatar
  """
  picture: URL
}

type UpdatePokerTemplateDimensionScalePayload {
  error: StandardMutationError
  dimension: TemplateDimension
}

type UpdatePokerTemplateScaleValuePayload {
  error: StandardMutationError
  scale: TemplateScale
}

"""
A value for a scale
"""
input TemplateScaleInput {
  """
  The color used to visually group a scale value
  """
  color: String!

  """
  The label for this value, e.g., XS, M, L
  """
  label: String!
}

type UpdateNewCheckInQuestionPayload {
  error: StandardMutationError
  meeting: NewMeeting
}

input UpdateDragLocationInput {
  id: ID!
  clientHeight: Float!
  clientWidth: Float!
  meetingId: ID!

  """
  The primary key of the item being drug
  """
  sourceId: ID!

  """
  The estimated destination of the item being drug
  """
  targetId: ID

  """
  The teamId to broadcast the message to
  """
  teamId: ID!

  """
  horizontal distance from the top left of the target
  """
  targetOffsetX: Float

  """
  vertical distance from the top left of the target
  """
  targetOffsetY: Float

  """
  the left of the source, relative to the client window
  """
  clientX: Float

  """
  the top of the source, relative to the client window
  """
  clientY: Float
}

"""
Return object for UpdatePokerScopePayload
"""
union UpdatePokerScopePayload = ErrorPayload | UpdatePokerScopeSuccess

type UpdatePokerScopeSuccess {
  """
  The meeting with the updated estimate phases
  """
  meeting: PokerMeeting!

  """
  The estimate stages added to the meeting
  """
  newStages: [EstimateStage!]!
}

input UpdatePokerScopeItemInput {
  """
  The location of the single source of truth (e.g. a jira-integrated parabol task would be "jira")
  """
  service: TaskServiceEnum!

  """
  If vanilla parabol task, taskId. If integrated parabol task, integrationHash
  """
  serviceTaskId: ID!

  """
  The action to perform
  """
  action: AddOrDeleteEnum!
}

"""
Option to add or delete
"""
enum AddOrDeleteEnum {
  ADD
  DELETE
}

type UpdateReflectionContentPayload {
  error: StandardMutationError
  meeting: NewMeeting
  reflection: RetroReflection
}

type UpdateReflectionGroupTitlePayload {
  error: StandardMutationError
  meeting: NewMeeting
  reflectionGroup: RetroReflectionGroup
}

"""
Return object for UpdateRetroMaxVotesPayload
"""
union UpdateRetroMaxVotesPayload = ErrorPayload | UpdateRetroMaxVotesSuccess

type UpdateRetroMaxVotesSuccess {
  """
  the meeting with the updated max votes
  """
  meeting: RetrospectiveMeeting!
}

type UpdateTaskPayload {
  error: StandardMutationError
  task: Task

  """
  If a task was just turned private, this its ID, else null
  """
  privatizedTaskId: ID
  addedNotification: NotifyTaskInvolves
}

input UpdateTaskInput {
  """
  The task id
  """
  id: ID!
  content: String
  sortOrder: Float
  status: TaskStatusEnum

  """
  userId, the owner of the task. This can be null if the task is not assigned to anyone.
  """
  userId: ID
}

type UpdateTaskDueDatePayload {
  error: StandardMutationError
  task: Task
}

type UpdateTeamNamePayload {
  error: StandardMutationError
  team: Team
}

input UpdatedTeamInput {
  id: ID!

  """
  The name of the team
  """
  name: String!

  """
  A link to the team’s profile image.
  """
  picture: URL
}

"""
Return object for UpdateTemplateScopePayload
"""
union UpdateTemplateScopePayload = ErrorPayload | UpdateTemplateScopeSuccess

type UpdateTemplateScopeSuccess {
  """
  the template that was just updated, if downscoped, does not provide whole story
  """
  template: MeetingTemplate!

  """
  if downscoping a previously used template, this will be the replacement
  """
  clonedTemplate: MeetingTemplate

  """
  The settings that contain the teamTemplates array that was modified
  """
  settings: TeamMeetingSettings!
}

type UpdateUserProfilePayload {
  error: StandardMutationError
  user: User

  """
  The updated team member
  """
  teamMembers: [TeamMember!]
}

input UpdateUserProfileInput {
  """
  A link to the user’s profile image.
  """
  picture: URL

  """
  The name, as confirmed by the user
  """
  preferredName: String
}

type UpgradeToTeamTierPayload {
  error: StandardMutationError

  """
  The new Team Org
  """
  organization: Organization

  """
  The updated teams under the org
  """
  teams: [Team!]

  """
  the ids of the meetings that were showing conversion modals
  """
  meetingIds: [ID!]

  """
  the meetings that were showing conversion modals
  """
  meetings: [NewMeeting!]
}

scalar File

type VoteForReflectionGroupPayload {
  error: StandardMutationError
  meeting: RetrospectiveMeeting
  meetingMember: RetrospectiveMeetingMember
  reflectionGroup: RetroReflectionGroup

  """
  The stages that were locked or unlocked by having at least 1 vote
  """
  unlockedStages: [NewMeetingStage!]
}

"""
Return object for VoteForPokerStoryPayload
"""
union VoteForPokerStoryPayload = ErrorPayload | VoteForPokerStorySuccess

type VoteForPokerStorySuccess {
  """
  The stage that holds the updated scores
  """
  stage: EstimateStage!
}

"""
Return object for PokerRevealVotesPayload
"""
union PokerRevealVotesPayload = ErrorPayload | PokerRevealVotesSuccess

type PokerRevealVotesSuccess {
  """
  The stage that holds the updated isVoting step
  """
  stage: EstimateStage!
}

"""
Return object for PokerResetDimensionPayload
"""
union PokerResetDimensionPayload = ErrorPayload | PokerResetDimensionSuccess

type PokerResetDimensionSuccess {
  """
  The stage that holds the updated isVoting step
  """
  stage: EstimateStage!
}

"""
Return object for PokerAnnounceDeckHoverPayload
"""
union PokerAnnounceDeckHoverPayload = ErrorPayload | PokerAnnounceDeckHoverSuccess

type PokerAnnounceDeckHoverSuccess {
  meetingId: ID!
  stageId: ID!
  userId: ID!
  user: User!
  isHover: Boolean!

  """
  The stage that holds the updated scores
  """
  stage: EstimateStage!
}

"""
Return object for MovePokerTemplateScaleValuePayload
"""
union MovePokerTemplateScaleValuePayload = ErrorPayload | MovePokerTemplateScaleValueSuccess

type MovePokerTemplateScaleValueSuccess {
  """
  The scale after values are moved
  """
  scale: TemplateScale!
}

"""
Return object for JoinMeetingPayload
"""
union JoinMeetingPayload = ErrorPayload | JoinMeetingSuccess

type JoinMeetingSuccess {
  meetingId: ID!

  """
  The meeting with the updated stages, if any
  """
  meeting: NewMeeting!
}

"""
Return object for SetPokerSpectatePayload
"""
union SetPokerSpectatePayload = ErrorPayload | SetPokerSpectateSuccess

type SetPokerSpectateSuccess {
  meetingId: ID!
  userId: ID!

  """
  The meeting member with the updated isSpectating value
  """
  meetingMember: PokerMeetingMember!

  """
  The stages that were updated if the viewer voted and then changed to spectating
  """
  updatedStages: [EstimateStage!]!
}

"""
Return object for PersistGitHubSearchQueryPayload
"""
union PersistGitHubSearchQueryPayload = ErrorPayload | PersistGitHubSearchQuerySuccess

type PersistGitHubSearchQuerySuccess {
  """
  The affected teamId
  """
  teamId: ID!

  """
  The affected userId
  """
  userId: ID!

  """
  The auth with the updated search queries
  """
  githubIntegration: GitHubIntegration!
}

"""
Return object for SetTaskEstimatePayload
"""
union SetTaskEstimatePayload = ErrorPayload | SetTaskEstimateSuccess

type SetTaskEstimateSuccess {
  task: Task!

  """
  The stage that holds the updated finalScore, if meetingId was provided
  """
  stage: EstimateStage
}

input TaskEstimateInput {
  taskId: ID!

  """
  The new estimate value
  """
  value: String!

  """
  The name of the estimate, e.g. Story Points
  """
  dimensionName: String!
  meetingId: ID
}

"""
Return object for ToggleTeamDrawerPayload
"""
union ToggleTeamDrawerPayload = ErrorPayload | ToggleTeamDrawerSuccess

type ToggleTeamDrawerSuccess {
  teamMember: TeamMember!
}

"""
Return object for UpdateGitHubDimensionFieldPayload
"""
union UpdateGitHubDimensionFieldPayload = ErrorPayload | UpdateGitHubDimensionFieldSuccess

type UpdateGitHubDimensionFieldSuccess {
  teamId: ID!
  meetingId: ID!
  team: Team!

  """
  The poker meeting the field was updated from
  """
  meeting: PokerMeeting!
}

"""
Return object for CreatePollPayload
"""
union CreatePollPayload = ErrorPayload | CreatePollSuccess

type CreatePollSuccess {
  """
  Poll id in a format of `poll:idGeneratedByDatabase`
  """
  pollId: ID!

  """
  the poll just created
  """
  poll: Poll!
}

"""
A poll created during the meeting
"""
type Poll implements Threadable {
  """
  Poll id in a format of `poll:idGeneratedByDatabase`
  """
  id: ID!

  """
  The rich text body of the item
  """
  content: String!

  """
  The timestamp the item was created
  """
  createdAt: DateTime!

  """
  The userId that created the item
  """
  createdBy: ID

  """
  The user that created the item
  """
  createdByUser: User!

  """
  the replies to this threadable item
  """
  replies: [Threadable!]!

  """
  The FK of the discussion this task was created in. Null if task was not created in a discussion
  """
  discussionId: ID

  """
  the parent, if this threadable is a reply, else null
  """
  threadParentId: ID

  """
  the order of this threadable, relative to threadParentId
  """
  threadSortOrder: Float

  """
  The timestamp the item was updated
  """
  updatedAt: DateTime!

  """
  The foreign key for the meeting the poll was created in
  """
  meetingId: ID

  """
  The id of the team (indexed)
  """
  teamId: ID!

  """
  The team this poll belongs to
  """
  team: Team!

  """
  Poll title
  """
  title: String!

  """
  A list of all the poll options related to this poll
  """
  options: [PollOption!]!
}

"""
Poll options for a given poll
"""
type PollOption {
  """
  Poll option id in a format of `pollOption:idGeneratedByDatabase`
  """
  id: ID!

  """
  The timestamp the item was created
  """
  createdAt: DateTime!

  """
  The timestamp the item was updated
  """
  updatedAt: DateTime!

  """
  The foreign key of the poll this option belongs to in a format of `poll:idGeneratedByDatabase`
  """
  pollId: ID!

  """
  The poll this option belongs to
  """
  poll: Poll!

  """
  The ids of the users who voted for this option
  """
  voteUserIds: [ID!]!

  """
  Poll option title
  """
  title: String!
}

input CreatePollInput {
  """
  Foreign key for the discussion this was created in
  """
  discussionId: ID!

  """
  The order of this threadable
  """
  threadSortOrder: Float!

  """
  Poll question
  """
  title: String!

  """
  All the poll voting options
  """
  options: [PollOptionInput!]!
}

input PollOptionInput {
  """
  Poll option title
  """
  title: String!
}

"""
Return object for AddTeamMemberIntegrationAuthPayload
"""
union AddTeamMemberIntegrationAuthPayload = ErrorPayload | AddTeamMemberIntegrationAuthSuccess

type AddTeamMemberIntegrationAuthSuccess {
  """
  The auth that was just added
  """
  integrationAuth: TeamMemberIntegrationAuth!

  """
  The service this provider is associated with
  """
  service: IntegrationProviderServiceEnum!

  """
  The team member with the updated auth
  """
  teamMember: TeamMember!

  """
  The user who updated TeamMemberIntegrationAuth object
  """
  user: User!
}

"""
Return object for AddIntegrationProviderPayload
"""
union AddIntegrationProviderPayload = ErrorPayload | AddIntegrationProviderSuccess

type AddIntegrationProviderSuccess {
  """
  The provider that was added
  """
  provider: IntegrationProvider!

  """
  Id of the team with the updated Integration Provider
  """
  teamId: ID!

  """
  The team with the updated Integration Provider
  """
  team: Team!
}

"""
An Integration Provider configuration
"""
input AddIntegrationProviderInput {
  """
  The team that the token is linked to
  """
  teamId: ID!

  """
  The service this provider is associated with
  """
  service: IntegrationProviderServiceEnum!

  """
  The kind of token used by this provider
  """
  authStrategy: IntegrationProviderAuthStrategyEnum!

  """
  The scope this provider configuration was created at (org-wide, or by the team)
  """
  scope: IntegrationProviderEditableScopeEnum!

  """
  Webhook provider metadata, has to be non-null if token type is webhook, refactor once we get https://github.com/graphql/graphql-spec/pull/825
  """
  webhookProviderMetadataInput: IntegrationProviderMetadataInputWebhook

  """
  OAuth1 provider metadata, has to be non-null if token type is OAuth1, refactor once we get https://github.com/graphql/graphql-spec/pull/825
  """
  oAuth1ProviderMetadataInput: IntegrationProviderMetadataInputOAuth1

  """
  OAuth2 provider metadata, has to be non-null if token type is OAuth2, refactor once we get https://github.com/graphql/graphql-spec/pull/825
  """
  oAuth2ProviderMetadataInput: IntegrationProviderMetadataInputOAuth2
}

"""
The scope this provider was created on by a user (excluding global scope)
"""
enum IntegrationProviderEditableScopeEnum {
  org
  team
}

"""
Webhook provider metadata
"""
input IntegrationProviderMetadataInputWebhook {
  """
  Webhook URL to be used by the provider
  """
  webhookUrl: URL!
}

"""
OAuth1 provider metadata
"""
input IntegrationProviderMetadataInputOAuth1 {
  """
  The base URL used to access the provider
  """
  serverBaseUrl: URL!

  """
  The client key to give to the provider
  """
  consumerKey: ID!

  """
  Secret or Private key of the generate private/public key pair
  """
  consumerSecret: String!
}

"""
OAuth2 provider metadata
"""
input IntegrationProviderMetadataInputOAuth2 {
  """
  The base URL used to access the provider
  """
  serverBaseUrl: URL!

  """
  The client id to give to the provider
  """
  clientId: String!

  """
  The client id to give to the provider
  """
  clientSecret: String!
}

"""
Return object for UpdateIntegrationProviderPayload
"""
union UpdateIntegrationProviderPayload = ErrorPayload | UpdateIntegrationProviderSuccess

type UpdateIntegrationProviderSuccess {
  """
  The provider that was updated
  """
  provider: IntegrationProvider!

  """
  The team member with the updated auth
  """
  teamMember: TeamMember!

  """
  The user who updated TeamMemberIntegrationAuth object
  """
  user: User!
}

"""
An Integration Provider configuration
"""
input UpdateIntegrationProviderInput {
  """
  The the id of the Integration Provider to update
  """
  id: ID!

  """
  The new scope for this provider (org, team)
  """
  scope: IntegrationProviderEditableScopeEnum

  """
  Webhook provider metadata, has to be non-null if token type is webhook, refactor once we get https://github.com/graphql/graphql-spec/pull/825
  """
  webhookProviderMetadataInput: IntegrationProviderMetadataInputWebhook

  """
  OAuth2 provider metadata, has to be non-null if token type is OAuth2, refactor once we get https://github.com/graphql/graphql-spec/pull/825
  """
  oAuth2ProviderMetadataInput: IntegrationProviderMetadataInputOAuth2
}

"""
Return object for RemoveIntegrationProviderPayload
"""
union RemoveIntegrationProviderPayload = ErrorPayload | RemoveIntegrationProviderSuccess

type RemoveIntegrationProviderSuccess {
  """
  The team member with the updated auth
  """
  teamMember: TeamMember!

  """
  The user who updated TeamMemberIntegrationAuth object
  """
  user: User!
}

"""
Return object for RemoveTeamMemberIntegrationAuthPayload
"""
union RemoveTeamMemberIntegrationAuthPayload = ErrorPayload | RemoveTeamMemberIntegrationAuthSuccess

type RemoveTeamMemberIntegrationAuthSuccess {
  """
  The team member with the updated auth
  """
  teamMember: TeamMember!

  """
  The user who updated TeamMemberIntegrationAuth object
  """
  user: User!
}

type Subscription {
  meetingSubscription(meetingId: ID!): MeetingSubscriptionPayload!
  notificationSubscription: NotificationSubscriptionPayload!
  organizationSubscription: OrganizationSubscriptionPayload!
  taskSubscription: TaskSubscriptionPayload!
  teamSubscription: TeamSubscriptionPayload!
}

union MeetingSubscriptionPayload =
    AddCommentSuccess
  | CreatePollSuccess
  | AddReactjiToReflectionSuccess
  | AddReactjiToReactableSuccess
  | AutoGroupReflectionsPayload
  | CreateReflectionPayload
  | DeleteCommentSuccess
  | DragDiscussionTopicPayload
  | DragEstimatingTaskSuccess
  | EditCommentingSuccess
  | EditReflectionPayload
  | EndDraggingReflectionPayload
  | FlagReadyToAdvanceSuccess
  | NewMeetingCheckInPayload
  | PromoteNewMeetingFacilitatorPayload
  | RemoveReflectionPayload
  | ResetRetroMeetingToGroupStagePayload
  | SetPhaseFocusPayload
  | SetStageTimerPayload
  | StartDraggingReflectionPayload
  | SetTaskHighlightSuccess
  | UpdateCommentContentSuccess
  | UpdateDragLocationPayload
  | UpdateNewCheckInQuestionPayload
  | UpdateReflectionContentPayload
  | UpdateReflectionGroupTitlePayload
  | UpdateRetroMaxVotesSuccess
  | UpdatePokerScopeSuccess
  | VoteForReflectionGroupPayload
  | VoteForPokerStorySuccess
  | PokerRevealVotesSuccess
  | PokerResetDimensionSuccess
  | PokerAnnounceDeckHoverSuccess
  | JoinMeetingSuccess
  | SetPokerSpectateSuccess
  | SetTaskEstimateSuccess

type AddReactjiToReflectionSuccess {
  """
  the reflection with the updated list of reactjis
  """
  reflection: RetroReflection!
}

type UpdateDragLocationPayload {
  """
  The drag as sent from the team member
  """
  remoteDrag: RemoteReflectionDrag
  userId: ID!
}

union NotificationSubscriptionPayload =
    AddNewFeaturePayload
  | AddOrgPayload
  | AddTeamPayload
  | ArchiveTimelineEventSuccess
  | SetNotificationStatusPayload
  | CreateTaskPayload
  | DeleteTaskPayload
  | DisconnectSocketPayload
  | EndCheckInSuccess
  | EndNewMeetingPayload
  | EndRetrospectiveSuccess
  | InvalidateSessionsPayload
  | InviteToTeamPayload
  | MeetingStageTimeLimitPayload
  | RemoveOrgUserPayload
  | StripeFailPaymentPayload
  | PersistJiraSearchQuerySuccess
  | User
  | AuthTokenPayload
  | PersistGitHubSearchQuerySuccess

type AddNewFeaturePayload {
  """
  the new feature broadcast
  """
  newFeature: NewFeatureBroadcast
}

type DisconnectSocketPayload {
  """
  The user that disconnected
  """
  user: User
}

type EndNewMeetingPayload {
  error: StandardMutationError

  """
  true if the meeting was killed (ended before reaching last stage)
  """
  isKill: Boolean
  team: Team
  meeting: NewMeeting

  """
  The ID of the suggestion to try a retro meeting, if tried
  """
  removedSuggestedActionId: ID
  removedTaskIds: [ID!]

  """
  An event that is important to the viewer, e.g. an ended meeting
  """
  timelineEvent: TimelineEvent
  updatedTaskIds: [ID!]

  """
  Any tasks that were updated during the meeting
  """
  updatedTasks: [Task!]
}

type MeetingStageTimeLimitPayload {
  """
  The new notification that was just created
  """
  notification: NotificationMeetingStageTimeLimitEnd!
}

"""
A notification sent to a facilitator that the stage time limit has ended
"""
type NotificationMeetingStageTimeLimitEnd implements Notification & TeamNotification {
  """
  A shortid for the notification
  """
  id: ID!

  """
  UNREAD if new, READ if viewer has seen it, CLICKED if viewed clicked it
  """
  status: NotificationStatusEnum!

  """
  The datetime to activate the notification & send it to the client
  """
  createdAt: DateTime!
  type: NotificationEnum!

  """
  *The userId that should see this notification
  """
  userId: ID!

  """
  FK
  """
  meetingId: ID!

  """
  The meeting that had the time limit expire
  """
  meeting: NewMeeting!
}

type StripeFailPaymentPayload {
  error: StandardMutationError
  organization: Organization

  """
  The notification to a billing leader stating the payment was rejected
  """
  notification: NotifyPaymentRejected!
}

"""
A notification sent to a user when their payment has been rejected
"""
type NotifyPaymentRejected implements Notification {
  organization: Organization!

  """
  A shortid for the notification
  """
  id: ID!

  """
  UNREAD if new, READ if viewer has seen it, CLICKED if viewed clicked it
  """
  status: NotificationStatusEnum!

  """
  The datetime to activate the notification & send it to the client
  """
  createdAt: DateTime!
  type: NotificationEnum!

  """
  *The userId that should see this notification
  """
  userId: ID!
}

"""
An auth token provided by Parabol to the client
"""
type AuthTokenPayload {
  """
  The encoded JWT
  """
  id: ID!
}

union OrganizationSubscriptionPayload =
    AddOrgPayload
  | ArchiveOrganizationPayload
  | DowngradeToStarterPayload
  | PayLaterPayload
  | RemoveOrgUserPayload
  | SetOrgUserRoleAddedPayload
  | SetOrgUserRoleRemovedPayload
  | UpdateCreditCardPayload
  | UpdateOrgPayload
  | UpgradeToTeamTierPayload
  | UpdateTemplateScopeSuccess

type SetOrgUserRoleAddedPayload implements SetOrgUserRolePayload {
  error: StandardMutationError
  organization: Organization
  updatedOrgMember: OrganizationUser

  """
  If promoted, notify them and give them all other admin notifications
  """
  notificationsAdded: [Notification]
}

type SetOrgUserRoleRemovedPayload implements SetOrgUserRolePayload {
  error: StandardMutationError
  organization: Organization
  updatedOrgMember: OrganizationUser
}

union TaskSubscriptionPayload =
    ChangeTaskTeamPayload
  | CreateTaskIntegrationPayload
  | CreateTaskPayload
  | DeleteTaskPayload
  | EditTaskPayload
  | RemoveOrgUserPayload
  | RemoveTeamMemberPayload
  | UpdateTaskPayload
  | UpdateTaskDueDatePayload

union TeamSubscriptionPayload =
    AddAgendaItemPayload
  | AddAtlassianAuthPayload
  | AddGitHubAuthPayload
  | AddIntegrationProviderSuccess
  | AddSlackAuthPayload
  | AddTeamPayload
  | ArchiveTeamPayload
  | DenyPushInvitationPayload
  | DowngradeToStarterPayload
  | EndCheckInSuccess
  | EndNewMeetingPayload
  | EndRetrospectiveSuccess
  | EndSprintPokerSuccess
  | NavigateMeetingPayload
  | PushInvitationPayload
  | PromoteToTeamLeadPayload
  | RemoveAgendaItemPayload
  | RemoveOrgUserPayload
  | RemoveTeamMemberPayload
  | RenameMeetingSuccess
  | SelectTemplatePayload
  | StartCheckInSuccess
  | StartNewMeetingPayload
  | StartRetrospectiveSuccess
  | StartSprintPokerSuccess
  | UpdateAgendaItemPayload
  | UpdateCreditCardPayload
  | UpdateTeamNamePayload
  | UpgradeToTeamTierPayload
  | AddReflectTemplatePayload
  | AddPokerTemplatePayload
  | AddReflectTemplatePromptPayload
  | AddPokerTemplateDimensionPayload
  | AddPokerTemplateScalePayload
  | AddPokerTemplateScaleValuePayload
  | MoveReflectTemplatePromptPayload
  | MovePokerTemplateDimensionPayload
  | ReflectTemplatePromptUpdateDescriptionPayload
  | PokerTemplateDimensionUpdateDescriptionPayload
  | ReflectTemplatePromptUpdateGroupColorPayload
  | RemoveAtlassianAuthPayload
  | RemoveGitHubAuthPayload
  | RemoveSlackAuthPayload
  | RemoveReflectTemplatePayload
  | RemovePokerTemplatePayload
  | RemoveReflectTemplatePromptPayload
  | RemovePokerTemplateDimensionPayload
  | RemovePokerTemplateScalePayload
  | RenameMeetingTemplatePayload
  | RenamePokerTemplatePayload
  | RenameReflectTemplatePromptPayload
  | RenamePokerTemplateDimensionPayload
  | RenamePokerTemplateScalePayload
  | RemovePokerTemplateScaleValuePayload
  | SetMeetingSettingsPayload
  | SetSlackNotificationPayload
  | UpdatePokerTemplateDimensionScalePayload
  | UpdatePokerTemplateScaleValuePayload
  | UpdateUserProfilePayload
  | PersistJiraSearchQuerySuccess
  | MovePokerTemplateScaleValueSuccess
  | SetDefaultSlackChannelSuccess
  | SetAppLocationSuccess
  | UpdateGitHubDimensionFieldSuccess
  | UpdateIntegrationProviderSuccess

type StartNewMeetingPayload {
  error: StandardMutationError
  team: Team
  meetingId: ID
  meeting: NewMeeting
}

type RenamePokerTemplatePayload {
  error: StandardMutationError
  pokerTemplate: PokerTemplate
}
