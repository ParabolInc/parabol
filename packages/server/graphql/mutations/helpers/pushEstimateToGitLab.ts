import {GraphQLResolveInfo} from 'graphql'
import {GQLContext} from '../../graphql'
import {ITaskEstimateInput} from '../../types/TaskEstimateInput'

const pushEstimateToGitLab = async (
  taskEstimate: ITaskEstimateInput,
  context: GQLContext,
  info: GraphQLResolveInfo,
  stageId: string | undefined
) => {
  const {dimensionName, taskId, value, meetingId} = taskEstimate
  const {dataLoader} = context
  const [task, meeting] = await Promise.all([
    dataLoader.get('tasks').load(taskId),
    meetingId ? dataLoader.get('newMeetings').load(meetingId) : undefined
  ])
  const gitlabIntegration = task.integration as Extract<
    typeof task.integration,
    {service: 'gitlab'}
  >
  const {teamId} = task
  const {accessUserId, gid} = gitlabIntegration
  const [auth, fieldMap] = await Promise.all([
    dataLoader
      .get('teamMemberIntegrationAuths')
      .load({service: 'gitlab', teamId, userId: accessUserId}),
    dataLoader.get('gitlabDimensionFieldMaps').load({teamId, dimensionName, gid})
  ])
  if (!auth) return new Error('User no longer has access to GitHub')
  // const labelTemplate = fieldMap?.labelTemplate ?? SprintPokerDefaults.SERVICE_FIELD_COMMENT
  // if (labelTemplate === SprintPokerDefaults.SERVICE_FIELD_NULL) return undefined
  // const {repoName, repoOwner} = GitHubRepoId.split(nameWithOwner)

  // // Set up gitlabRequest
  // const gitlabLabelName = interpolateGitHubLabelTemplate(labelTemplate, value)
  // const {accessToken} = auth
  // const gitlabRequest = getGitHubRequest(info, context, {
  //   accessToken,
  //   headers: {Accept: 'application/vnd.gitlab.bane-preview+json'}
  // })

  // if (labelTemplate === SprintPokerDefaults.SERVICE_FIELD_COMMENT) {
  //   if (!stageId || !meeting) return new Error('Cannot add jira comment for non-meeting estimates')

  //   // get the issue ID
  //   const [issueRes, issueResError] = await gitlabRequest<
  //     GetIssueIdQuery,
  //     GetIssueIdQueryVariables
  //   >(getIssueId, {
  //     name: repoName,
  //     owner: repoOwner,
  //     number: issueNumber
  //   })
  //   if (issueResError) return issueResError
  //   const {repository} = issueRes
  //   if (!repository) return new Error('Repository not found on GitHub')

  //   const {issue} = repository
  //   if (!issue) return new Error('Issue not found on GitHub')

  //   const {id: issueId} = issue
  //   const {name: meetingName, phases} = meeting
  //   const estimatePhase = getPhase(phases, 'ESTIMATE')
  //   const {stages} = estimatePhase
  //   const stageIdx = stages.findIndex((stage) => stage.id === stageId)
  //   const discussionURL = makeAppURL(appOrigin, `meet/${meetingId}/estimate/${stageIdx + 1}`)
  //   const body = makeScoreGitHubComment(
  //     dimensionName,
  //     value || '<None>',
  //     meetingName,
  //     discussionURL
  //   )

  //   const [, commentError] = await gitlabRequest<AddCommentMutation, AddCommentMutationVariables>(
  //     addComment,
  //     {
  //       input: {
  //         body,
  //         subjectId: issueId
  //       }
  //     }
  //   )
  //   if (commentError) return commentError
  //   return undefined
  // }

  // const [repoLabelsRes, repoLabelsError] = await gitlabRequest<
  //   GetRepoLabelsQuery,
  //   GetRepoLabelsQueryVariables
  // >(getRepoLabels, {
  //   name: repoName,
  //   owner: repoOwner,
  //   issueNumber,
  //   first: 100
  // })
  // if (repoLabelsError) return repoLabelsError

  // const {repository} = repoLabelsRes
  // if (!repository) return new Error('Repository not found on GitHub')

  // const {id: repositoryId, labels, issue} = repository
  // if (!labels) return new Error('Labels for repository not found')
  // if (!issue) return new Error(`Issue #${issueNumber} not found`)

  // const {id: issueId, labels: issueLabels} = issue
  // const {nodes} = labels
  // if (!nodes) return new Error('Label nodes not found')
  // if (!issueLabels) return new Error('Issue labels not found')

  // const {nodes: nullableIssueLabelNodes} = issueLabels
  // if (!nullableIssueLabelNodes) return new Error('Issue label nodes not found')

  // const issueLabelNodes = nullableIssueLabelNodes.filter(isNotNull)
  // const labelNodes = nodes.filter(isNotNull)
  // const matchingLabel = labelNodes.find((node) => node.name === gitlabLabelName)
  // const DESCRIPTION_IDENTIFIER = 'Generated by Parabol'
  // let labelToAddId = matchingLabel?.id ?? ''
  // if (!matchingLabel) {
  //   let color = PALETTE.GRAPE_500.slice(1)
  //   if (meeting) {
  //     const {templateRefId} = meeting as MeetingPoker
  //     const templateRef = await dataLoader.get('templateRefs').loadNonNull(templateRefId)
  //     const {dimensions} = templateRef
  //     const dimensionRef = dimensions.find((dimension) => dimension.name === dimensionName)
  //     if (!dimensionRef) return new Error('Dimension not found')
  //     const {scaleRefId} = dimensionRef
  //     const scaleRef = await dataLoader.get('templateScaleRefs').loadNonNull(scaleRefId)
  //     const {values} = scaleRef
  //     const matchingValue = values.find((scaleValue) => scaleValue.label === value)
  //     if (matchingValue) {
  //       // remove # prefix
  //       color = matchingValue.color.slice(1)
  //     }
  //   } else {
  //     // TODO: https://gitlab.com/ParabolInc/parabol/issues/5426
  //   }

  //   // create a new label
  //   const [createLabelRes, createLabelError] = await gitlabRequest<
  //     CreateLabelMutation,
  //     CreateLabelMutationVariables
  //   >(createLabel, {
  //     input: {
  //       repositoryId,
  //       color,
  //       name: gitlabLabelName,
  //       description: DESCRIPTION_IDENTIFIER
  //     }
  //   })
  //   if (createLabelError) return createLabelError

  //   const {createLabel: createLabelRes2} = createLabelRes
  //   if (!createLabelRes2) return new Error('Could not create label')

  //   const {label} = createLabelRes2
  //   if (!label) return new Error('Could not get created label')

  //   labelToAddId = label.id
  // }
  // // DELETE OLD LABELS
  // const latestTaskEstimates = await dataLoader.get('latestTaskEstimates').load(taskId)
  // const dimensionTaskEstimate = latestTaskEstimates.find(
  //   (estimate) => estimate.name === dimensionName
  // )
  // if (dimensionTaskEstimate) {
  //   const {gitlabLabelName} = dimensionTaskEstimate
  //   const labelIdsToRemove = issueLabelNodes
  //     .filter((node) => node.name === gitlabLabelName)
  //     .map((node) => node.id)
  //   if (labelIdsToRemove.length > 0) {
  //     const [, removeLabelsError] = await gitlabRequest<
  //       RemoveLabelsMutation,
  //       RemoveLabelsMutationVariables
  //     >(removeLabels, {
  //       input: {
  //         labelableId: issueId,
  //         labelIds: labelIdsToRemove
  //       }
  //     })
  //     if (removeLabelsError) return removeLabelsError
  //   }
  // }

  // // ADD NEW LABEL
  // const [, addLabelError] = await gitlabRequest<AddLabelMutation, AddLabelMutationVariables>(
  //   addLabel,
  //   {
  //     input: {
  //       labelableId: issueId,
  //       labelIds: [labelToAddId]
  //     }
  //   }
  // )
  // if (addLabelError) return addLabelError
  // return gitlabLabelName
}

export default pushEstimateToGitLab
