import {Kysely, PostgresDialect, sql} from 'kysely'
import {Client} from 'pg'
import {r} from 'rethinkdb-ts'
import connectRethinkDB from '../../database/connectRethinkDB'
import getPg from '../getPg'
import getPgConfig from '../getPgConfig'

const START_CHAR_CODE = 32
const END_CHAR_CODE = 126

export function positionAfter(pos: string) {
  for (let i = pos.length - 1; i >= 0; i--) {
    const curCharCode = pos.charCodeAt(i)
    if (curCharCode < END_CHAR_CODE) {
      return pos.substr(0, i) + String.fromCharCode(curCharCode + 1)
    }
  }
  return pos + String.fromCharCode(START_CHAR_CODE + 1)
}

export async function up() {
  await connectRethinkDB()
  const pg = new Kysely<any>({
    dialect: new PostgresDialect({
      pool: getPg()
    })
  })
  await sql`
  DO $$
  BEGIN
    CREATE TABLE IF NOT EXISTS "TemplateScale" (
      "id" VARCHAR(100) PRIMARY KEY,
      "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
      "name" VARCHAR(50) NOT NULL,
      "teamId" VARCHAR(100) NOT NULL,
      "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
      "parentScaleId" VARCHAR(100),
      "isStarter" BOOLEAN NOT NULL DEFAULT FALSE,
      "removedAt" TIMESTAMP WITH TIME ZONE,
      CONSTRAINT "fk_teamId"
        FOREIGN KEY("teamId")
          REFERENCES "Team"("id")
          ON DELETE CASCADE
    );
    CREATE INDEX IF NOT EXISTS "idx_TemplateScale_teamId" ON "TemplateScale"("teamId") WHERE "removedAt" IS NULL;
    DROP TRIGGER IF EXISTS "update_TemplateScale_updatedAt" ON "TemplateScale";
    CREATE TRIGGER "update_TemplateScale_updatedAt" BEFORE UPDATE ON "TemplateScale" FOR EACH ROW EXECUTE PROCEDURE "set_updatedAt"();

    CREATE TABLE IF NOT EXISTS "TemplateScaleValue" (
      "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      "templateScaleId" VARCHAR(100) NOT NULL,
      "sortOrder" VARCHAR(64) NOT NULL COLLATE "C",
      "color" VARCHAR(9) NOT NULL,
      "label" VARCHAR(18) NOT NULL,
      UNIQUE ("templateScaleId","label"),
      CONSTRAINT "fk_templateScaleId"
        FOREIGN KEY("templateScaleId")
          REFERENCES "TemplateScale"("id")
          ON DELETE CASCADE
    );
    CREATE INDEX IF NOT EXISTS "idx_TemplateScaleValue_templateScaleId" ON "TemplateScaleValue"("templateScaleId");
    CREATE OR REPLACE FUNCTION "set_TemplateScale_updatedAt"()
      RETURNS TRIGGER AS $t$
      BEGIN
          -- Update the updatedAt column in TemplateScale
          UPDATE "TemplateScale"
          SET "updatedAt" = CURRENT_TIMESTAMP
          WHERE id = NEW."templateScaleId";
          RETURN NEW;
      END;
      $t$ LANGUAGE plpgsql;
    CREATE TRIGGER "update_TemplateScale_updatedAt_from_TemplateScaleValue"
    AFTER INSERT OR UPDATE OR DELETE ON "TemplateScaleValue"
    FOR EACH ROW
    EXECUTE FUNCTION "set_TemplateScale_updatedAt"();
  END $$;
`.execute(pg)

  const rTemplateScales = await r.table('TemplateScale').coerceTo('array').run()
  const templateScaleValues = [] as {
    templateScaleId: string
    sortOrder: string
    color: string
    label: string
  }[]
  const templateScales = rTemplateScales.map((templateScale) => {
    const {id, createdAt, name, teamId, updatedAt, parentScaleId, isStarter, removedAt, values} =
      templateScale
    let curSortOrder = ''
    const templateVals = values?.map((value) => {
      const sortOrder = positionAfter(curSortOrder)
      curSortOrder = sortOrder
      return {
        templateScaleId: id,
        sortOrder,
        color: value.color,
        label: value.label.slice(0, 8)
      }
    })
    templateScaleValues.push(...templateVals)
    return {id, createdAt, name, teamId, updatedAt, parentScaleId, isStarter, removedAt}
  })

  const chunk = (arr: any[], size: number) =>
    Array.from({length: Math.ceil(arr.length / size)}, (_, i) =>
      arr.slice(i * size, i * size + size)
    )

  const valueChunks = chunk(templateScaleValues, 10000)

  await pg.insertInto('TemplateScale').values(templateScales).execute()
  await Promise.all(
    valueChunks.map(async (chunk) => {
      try {
        return await pg.insertInto('TemplateScaleValue').values(chunk).execute()
      } catch (e) {
        await Promise.all(
          chunk.map(async (row) => {
            try {
              await pg
                .insertInto('TemplateScaleValue')
                .values(row)
                .onConflict((oc) => oc.doNothing())
                .execute()
            } catch (e) {
              console.log(e, row)
            }
          })
        )
      }
    })
  )

  await pg.schema
    .alterTable('TemplateScale')
    .addForeignKeyConstraint('fk_parentScaleId', ['parentScaleId'], 'TemplateScale', ['id'])
    .onDelete('set null')
    .execute()
}

export async function down() {
  const client = new Client(getPgConfig())
  await client.connect()
  await client.query(`
    DROP TABLE IF EXISTS "TemplateScaleValue";
    DROP TABLE IF EXISTS "TemplateScale";
    ` /* Do undo magic */)
  await client.end()
}
