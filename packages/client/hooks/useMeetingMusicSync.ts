import graphql from 'babel-plugin-relay/macro'
import {useCallback, useEffect, useRef, useState} from 'react'
import {requestSubscription} from 'react-relay'
import SetMeetingMusicMutation from '../mutations/SetMeetingMusicMutation'
import useAtmosphere from './useAtmosphere'
import useBackgroundMusicManager from './useBackgroundMusicManager'

// Define subscription type (will be generated by Relay)
interface MusicSubscriptionData {
  meetingSubscription: {
    fieldName: string
    SetMeetingMusicSuccess?: {
      meetingId: string
      trackSrc: string | null
      isPlaying: boolean
      timestamp: number | null
    }
  }
}

interface MeetingMusicSyncProps {
  meetingId: string
  isFacilitator: boolean
}

const subscription = graphql`
  subscription useMeetingMusicSyncSubscription($meetingId: ID!) {
    meetingSubscription(meetingId: $meetingId) {
      fieldName
      SetMeetingMusicSuccess {
        meetingId
        trackSrc
        isPlaying
        timestamp
      }
    }
  }
`

const useMeetingMusicSync = (props: MeetingMusicSyncProps) => {
  const {meetingId, isFacilitator} = props
  const atmosphere = useAtmosphere()
  const [isInitialized, setIsInitialized] = useState(false)
  const receivedUpdate = useRef(false)
  // Keep track of pending music operations for autoplay handling
  const pendingPlay = useRef<{trackSrc: string; timestamp: number | null} | null>(null)

  const backgroundMusicManager = useBackgroundMusicManager({
    initialTrackUrl: null,
    initialIsPlaying: false,
    initialVolume: 0.5
  })

  const {playTrack, pause, stop, setVolume, selectTrack, currentTrackSrc, isPlaying, volume} =
    backgroundMusicManager

  // For non-facilitators, subscribe to music updates via GraphQL
  useEffect(() => {
    if (isFacilitator) return

    // Using Relay's built-in subscription mechanism
    const subscriptionConfig = {
      subscription,
      variables: {meetingId},
      onNext: (data: any) => {
        console.log('[MusicSync] Subscription data received:', data)
        if (data?.meetingSubscription) {
          const {fieldName, SetMeetingMusicSuccess} = data.meetingSubscription

          if (fieldName === 'SetMeetingMusicPayload' && SetMeetingMusicSuccess) {
            receivedUpdate.current = true
            const {trackSrc, isPlaying: shouldPlay, timestamp} = SetMeetingMusicSuccess

            console.log(
              `[MusicSync] Processing music update: track=${trackSrc}, play=${shouldPlay}`
            )

            if (trackSrc) {
              console.log(`[MusicSync] Setting track: ${trackSrc}`)
              selectTrack(trackSrc)

              if (shouldPlay) {
                console.log('[MusicSync] Playing track with delay')

                // Store pending play request and try with a longer delay to work around autoplay
                pendingPlay.current = {trackSrc, timestamp}

                // Try playing after a longer delay to work around some browser issues
                setTimeout(() => {
                  console.log('[MusicSync] Attempting to play track after delay')
                  playTrack(trackSrc)

                  // Try again after a longer delay if first attempt fails due to browser autoplay policies
                  setTimeout(() => {
                    if (pendingPlay.current?.trackSrc === trackSrc) {
                      console.log('[MusicSync] Second attempt to play track')
                      playTrack(trackSrc)
                      pendingPlay.current = null
                    }
                  }, 1000)
                }, 300)
              }
            } else if (shouldPlay === false) {
              console.log('[MusicSync] Stopping music')
              stop()
              pendingPlay.current = null
            }
          }
        }
      },
      onError: (error: Error) => {
        console.error('[MusicSync] Subscription error:', error)
      }
    }

    // Register subscription
    const {dispose} = requestSubscription(atmosphere, subscriptionConfig)

    return () => {
      console.log('[MusicSync] Disposing subscription')
      dispose()
    }
  }, [atmosphere, meetingId, isFacilitator, playTrack, selectTrack, stop])

  // Sync music state to the server when facilitator makes changes
  const syncMusicState = useCallback(
    (trackSrc: string | null, isPlaying: boolean) => {
      if (!isFacilitator || !isInitialized) return

      console.log(`[MusicSync] Facilitator syncing music: track=${trackSrc}, playing=${isPlaying}`)

      SetMeetingMusicMutation(
        atmosphere,
        {
          meetingId,
          trackSrc,
          isPlaying,
          timestamp: isPlaying && trackSrc ? Date.now() : null
        },
        {
          onError: (err) => console.error('[MusicSync] Error syncing music:', err),
          onCompleted: (res) => {
            console.log('[MusicSync] Mutation completed:', res)
          }
        }
      )
    },
    [atmosphere, meetingId, isFacilitator, isInitialized]
  )

  // Enhanced controls for the facilitator that sync to the server
  const enhancedControls = {
    playTrack: (trackSrc: string) => {
      console.log(`[MusicSync] Facilitator playing track: ${trackSrc}`)
      playTrack(trackSrc)
      syncMusicState(trackSrc, true)
    },
    pause: () => {
      console.log('[MusicSync] Facilitator pausing music')
      pause()
      syncMusicState(currentTrackSrc, false)
    },
    stop: () => {
      console.log('[MusicSync] Facilitator stopping music')
      stop()
      syncMusicState(null, false)
    },
    selectTrack: (trackSrc: string) => {
      console.log(`[MusicSync] Facilitator selecting track: ${trackSrc}`)
      selectTrack(trackSrc)
      syncMusicState(trackSrc, false)
    }
  }

  // Listen for custom events as a fallback
  useEffect(() => {
    if (isFacilitator) return // Only non-facilitators need to listen for updates

    console.log(`[MusicSync] Setting up event listener for meeting ${meetingId}`)

    const handleSetMeetingMusic = (e: CustomEvent) => {
      const data = e.detail
      if (!data || data.meetingId !== meetingId) {
        console.log('[MusicSync] Received event but not for this meeting')
        return
      }

      const {trackSrc, isPlaying: shouldPlay, timestamp} = data
      console.log(`[MusicSync] Received music event: track=${trackSrc}, playing=${shouldPlay}`)

      if (trackSrc) {
        console.log(`[MusicSync] Selecting track from event: ${trackSrc}`)
        selectTrack(trackSrc)
        if (shouldPlay) {
          console.log('[MusicSync] Playing track from event')

          // Store pending play request
          pendingPlay.current = {trackSrc, timestamp}

          setTimeout(() => {
            // Add a short delay to ensure the track is loaded
            playTrack(trackSrc)

            // Try again after a longer delay if first attempt fails due to browser autoplay policies
            setTimeout(() => {
              if (pendingPlay.current?.trackSrc === trackSrc) {
                console.log('[MusicSync] Second attempt to play track from event')
                playTrack(trackSrc)
                pendingPlay.current = null
              }
            }, 1000)
          }, 300)
        }
      } else if (!shouldPlay) {
        console.log('[MusicSync] Stopping music from event')
        stop()
        pendingPlay.current = null
      }
    }

    // Add event listener for music updates
    window.addEventListener('SetMeetingMusicSuccess', handleSetMeetingMusic as EventListener)

    return () => {
      console.log('[MusicSync] Removing event listener')
      window.removeEventListener('SetMeetingMusicSuccess', handleSetMeetingMusic as EventListener)
    }
  }, [meetingId, isFacilitator, playTrack, selectTrack, stop])

  // Add a document click listener to help with autoplay
  useEffect(() => {
    if (isFacilitator) return

    const handleDocumentClick = () => {
      // When user interacts with the page, check if we have a pending play request
      if (pendingPlay.current) {
        const {trackSrc} = pendingPlay.current
        console.log('[MusicSync] User interacted with page, playing pending track:', trackSrc)
        playTrack(trackSrc)
        pendingPlay.current = null
      }
    }

    document.addEventListener('click', handleDocumentClick)

    return () => {
      document.removeEventListener('click', handleDocumentClick)
    }
  }, [isFacilitator, playTrack])

  // Debug subscription status
  useEffect(() => {
    if (!isFacilitator) {
      // Check if we're actually receiving updates
      const checkInterval = setInterval(() => {
        if (!receivedUpdate.current) {
          console.log('[MusicSync] WARNING: No subscription updates received yet')
        }
      }, 5000) // Check every 5 seconds

      return () => clearInterval(checkInterval)
    }
  }, [isFacilitator])

  // Initialize the sync system
  useEffect(() => {
    console.log(
      `[MusicSync] Initializing as ${isFacilitator ? 'facilitator' : 'member'} for meeting ${meetingId}`
    )
    setIsInitialized(true)

    return () => {
      console.log(
        `[MusicSync] Cleaning up music sync for ${isFacilitator ? 'facilitator' : 'member'}`
      )
    }
  }, [isFacilitator, meetingId])

  return {
    ...backgroundMusicManager,
    // Override controls for facilitator to include syncing
    ...(isFacilitator ? enhancedControls : {})
  }
}

export default useMeetingMusicSync
